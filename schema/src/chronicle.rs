// Generated by Molecule 0.8.0
#![allow(unused)]

use molecule::prelude::*;
#[derive(Clone)]
pub struct UTF8Bytes(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for UTF8Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for UTF8Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for UTF8Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for UTF8Bytes {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        UTF8Bytes::new_unchecked(v)
    }
}
impl UTF8Bytes {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice(molecule::NUMBER_SIZE..)
    }
    pub fn as_reader<'r>(&'r self) -> UTF8BytesReader<'r> {
        UTF8BytesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for UTF8Bytes {
    type Builder = UTF8BytesBuilder;
    const NAME: &'static str = "UTF8Bytes";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        UTF8Bytes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UTF8BytesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UTF8BytesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct UTF8BytesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for UTF8BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for UTF8BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for UTF8BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> UTF8BytesReader<'r> {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[molecule::NUMBER_SIZE..]
    }
}
impl<'r> molecule::prelude::Reader<'r> for UTF8BytesReader<'r> {
    type Entity = UTF8Bytes;
    const NAME: &'static str = "UTF8BytesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        UTF8BytesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct UTF8BytesBuilder(pub(crate) Vec<Byte>);
impl UTF8BytesBuilder {
    pub const ITEM_SIZE: usize = 1;
    pub fn set(mut self, v: Vec<Byte>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Byte) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Byte) -> Option<Byte> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for UTF8BytesBuilder {
    type Entity = UTF8Bytes;
    const NAME: &'static str = "UTF8BytesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        UTF8Bytes::new_unchecked(inner.into())
    }
}
pub struct UTF8BytesIterator(UTF8Bytes, usize, usize);
impl ::core::iter::Iterator for UTF8BytesIterator {
    type Item = Byte;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for UTF8BytesIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for UTF8Bytes {
    type Item = Byte;
    type IntoIter = UTF8BytesIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        UTF8BytesIterator(self, 0, len)
    }
}
impl ::core::iter::FromIterator<Byte> for UTF8Bytes {
    fn from_iter<T: IntoIterator<Item = Byte>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
impl ::core::iter::FromIterator<u8> for UTF8Bytes {
    fn from_iter<T: IntoIterator<Item = u8>>(iter: T) -> Self {
        Self::new_builder()
            .extend(iter.into_iter().map(Into::into))
            .build()
    }
}
#[derive(Clone)]
pub struct TraitPool(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TraitPool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TraitPool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TraitPool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for TraitPool {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TraitPool::new_unchecked(v)
    }
}
impl TraitPool {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<UTF8Bytes> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> UTF8Bytes {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            UTF8Bytes::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            UTF8Bytes::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TraitPoolReader<'r> {
        TraitPoolReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TraitPool {
    type Builder = TraitPoolBuilder;
    const NAME: &'static str = "TraitPool";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TraitPool(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitPoolReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitPoolReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct TraitPoolReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TraitPoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TraitPoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TraitPoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> TraitPoolReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<UTF8BytesReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> UTF8BytesReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            UTF8BytesReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            UTF8BytesReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TraitPoolReader<'r> {
    type Entity = TraitPool;
    const NAME: &'static str = "TraitPoolReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TraitPoolReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            UTF8BytesReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TraitPoolBuilder(pub(crate) Vec<UTF8Bytes>);
impl TraitPoolBuilder {
    pub fn set(mut self, v: Vec<UTF8Bytes>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: UTF8Bytes) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = UTF8Bytes>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: UTF8Bytes) -> Option<UTF8Bytes> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for TraitPoolBuilder {
    type Entity = TraitPool;
    const NAME: &'static str = "TraitPoolBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TraitPool::new_unchecked(inner.into())
    }
}
pub struct TraitPoolIterator(TraitPool, usize, usize);
impl ::core::iter::Iterator for TraitPoolIterator {
    type Item = UTF8Bytes;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for TraitPoolIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for TraitPool {
    type Item = UTF8Bytes;
    type IntoIter = TraitPoolIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        TraitPoolIterator(self, 0, len)
    }
}
impl<'r> TraitPoolReader<'r> {
    pub fn iter<'t>(&'t self) -> TraitPoolReaderIterator<'t, 'r> {
        TraitPoolReaderIterator(&self, 0, self.len())
    }
}
pub struct TraitPoolReaderIterator<'t, 'r>(&'t TraitPoolReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for TraitPoolReaderIterator<'t, 'r> {
    type Item = UTF8BytesReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for TraitPoolReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<UTF8Bytes> for TraitPool {
    fn from_iter<T: IntoIterator<Item = UTF8Bytes>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
#[derive(Clone)]
pub struct NumberPool(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for NumberPool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for NumberPool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for NumberPool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for NumberPool {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        NumberPool::new_unchecked(v)
    }
}
impl NumberPool {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice(molecule::NUMBER_SIZE..)
    }
    pub fn as_reader<'r>(&'r self) -> NumberPoolReader<'r> {
        NumberPoolReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for NumberPool {
    type Builder = NumberPoolBuilder;
    const NAME: &'static str = "NumberPool";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        NumberPool(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberPoolReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberPoolReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct NumberPoolReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for NumberPoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for NumberPoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for NumberPoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> NumberPoolReader<'r> {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[molecule::NUMBER_SIZE..]
    }
}
impl<'r> molecule::prelude::Reader<'r> for NumberPoolReader<'r> {
    type Entity = NumberPool;
    const NAME: &'static str = "NumberPoolReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NumberPoolReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct NumberPoolBuilder(pub(crate) Vec<Byte>);
impl NumberPoolBuilder {
    pub const ITEM_SIZE: usize = 1;
    pub fn set(mut self, v: Vec<Byte>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Byte) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Byte) -> Option<Byte> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for NumberPoolBuilder {
    type Entity = NumberPool;
    const NAME: &'static str = "NumberPoolBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        NumberPool::new_unchecked(inner.into())
    }
}
pub struct NumberPoolIterator(NumberPool, usize, usize);
impl ::core::iter::Iterator for NumberPoolIterator {
    type Item = Byte;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for NumberPoolIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for NumberPool {
    type Item = Byte;
    type IntoIter = NumberPoolIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        NumberPoolIterator(self, 0, len)
    }
}
impl ::core::iter::FromIterator<Byte> for NumberPool {
    fn from_iter<T: IntoIterator<Item = Byte>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
impl ::core::iter::FromIterator<u8> for NumberPool {
    fn from_iter<T: IntoIterator<Item = u8>>(iter: T) -> Self {
        Self::new_builder()
            .extend(iter.into_iter().map(Into::into))
            .build()
    }
}
#[derive(Clone)]
pub struct NumberRange(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for NumberRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for NumberRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for NumberRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "min", self.min())?;
        write!(f, ", {}: {}", "max", self.max())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for NumberRange {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        NumberRange::new_unchecked(v)
    }
}
impl NumberRange {
    const DEFAULT_VALUE: [u8; 14] = [14, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn min(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn max(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte::new_unchecked(self.0.slice(start..end))
        } else {
            Byte::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> NumberRangeReader<'r> {
        NumberRangeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for NumberRange {
    type Builder = NumberRangeBuilder;
    const NAME: &'static str = "NumberRange";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        NumberRange(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberRangeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberRangeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().min(self.min()).max(self.max())
    }
}
#[derive(Clone, Copy)]
pub struct NumberRangeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for NumberRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for NumberRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for NumberRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "min", self.min())?;
        write!(f, ", {}: {}", "max", self.max())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> NumberRangeReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn min(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn max(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            ByteReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ByteReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for NumberRangeReader<'r> {
    type Entity = NumberRange;
    const NAME: &'static str = "NumberRangeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NumberRangeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ByteReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct NumberRangeBuilder {
    pub(crate) min: Byte,
    pub(crate) max: Byte,
}
impl NumberRangeBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn min(mut self, v: Byte) -> Self {
        self.min = v;
        self
    }
    pub fn max(mut self, v: Byte) -> Self {
        self.max = v;
        self
    }
}
impl molecule::prelude::Builder for NumberRangeBuilder {
    type Entity = NumberRange;
    const NAME: &'static str = "NumberRangeBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.min.as_slice().len()
            + self.max.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.min.as_slice().len();
        offsets.push(total_size);
        total_size += self.max.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.min.as_slice())?;
        writer.write_all(self.max.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        NumberRange::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Instruction(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Instruction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Instruction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Instruction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for Instruction {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Instruction::new_unchecked(v)
    }
}
impl Instruction {
    const DEFAULT_VALUE: [u8; 18] = [0, 0, 0, 0, 14, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0];
    pub const ITEMS_COUNT: usize = 3;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> InstructionUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => NumberRange::new_unchecked(inner).into(),
            1 => TraitPool::new_unchecked(inner).into(),
            2 => UTF8Bytes::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> InstructionReader<'r> {
        InstructionReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Instruction {
    type Builder = InstructionBuilder;
    const NAME: &'static str = "Instruction";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Instruction(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        InstructionReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        InstructionReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct InstructionReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for InstructionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for InstructionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for InstructionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> InstructionReader<'r> {
    pub const ITEMS_COUNT: usize = 3;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> InstructionUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => NumberRangeReader::new_unchecked(inner).into(),
            1 => TraitPoolReader::new_unchecked(inner).into(),
            2 => UTF8BytesReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for InstructionReader<'r> {
    type Entity = Instruction;
    const NAME: &'static str = "InstructionReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        InstructionReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => NumberRangeReader::verify(inner_slice, compatible),
            1 => TraitPoolReader::verify(inner_slice, compatible),
            2 => UTF8BytesReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct InstructionBuilder(pub(crate) InstructionUnion);
impl InstructionBuilder {
    pub const ITEMS_COUNT: usize = 3;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<InstructionUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for InstructionBuilder {
    type Entity = Instruction;
    const NAME: &'static str = "InstructionBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Instruction::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum InstructionUnion {
    NumberRange(NumberRange),
    TraitPool(TraitPool),
    UTF8Bytes(UTF8Bytes),
}
#[derive(Debug, Clone, Copy)]
pub enum InstructionUnionReader<'r> {
    NumberRange(NumberRangeReader<'r>),
    TraitPool(TraitPoolReader<'r>),
    UTF8Bytes(UTF8BytesReader<'r>),
}
impl ::core::default::Default for InstructionUnion {
    fn default() -> Self {
        InstructionUnion::NumberRange(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for InstructionUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            InstructionUnion::NumberRange(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberRange::NAME, item)
            }
            InstructionUnion::TraitPool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TraitPool::NAME, item)
            }
            InstructionUnion::UTF8Bytes(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, UTF8Bytes::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for InstructionUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            InstructionUnionReader::NumberRange(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberRange::NAME, item)
            }
            InstructionUnionReader::TraitPool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TraitPool::NAME, item)
            }
            InstructionUnionReader::UTF8Bytes(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, UTF8Bytes::NAME, item)
            }
        }
    }
}
impl InstructionUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            InstructionUnion::NumberRange(ref item) => write!(f, "{}", item),
            InstructionUnion::TraitPool(ref item) => write!(f, "{}", item),
            InstructionUnion::UTF8Bytes(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> InstructionUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            InstructionUnionReader::NumberRange(ref item) => write!(f, "{}", item),
            InstructionUnionReader::TraitPool(ref item) => write!(f, "{}", item),
            InstructionUnionReader::UTF8Bytes(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<NumberRange> for InstructionUnion {
    fn from(item: NumberRange) -> Self {
        InstructionUnion::NumberRange(item)
    }
}
impl ::core::convert::From<TraitPool> for InstructionUnion {
    fn from(item: TraitPool) -> Self {
        InstructionUnion::TraitPool(item)
    }
}
impl ::core::convert::From<UTF8Bytes> for InstructionUnion {
    fn from(item: UTF8Bytes) -> Self {
        InstructionUnion::UTF8Bytes(item)
    }
}
impl<'r> ::core::convert::From<NumberRangeReader<'r>> for InstructionUnionReader<'r> {
    fn from(item: NumberRangeReader<'r>) -> Self {
        InstructionUnionReader::NumberRange(item)
    }
}
impl<'r> ::core::convert::From<TraitPoolReader<'r>> for InstructionUnionReader<'r> {
    fn from(item: TraitPoolReader<'r>) -> Self {
        InstructionUnionReader::TraitPool(item)
    }
}
impl<'r> ::core::convert::From<UTF8BytesReader<'r>> for InstructionUnionReader<'r> {
    fn from(item: UTF8BytesReader<'r>) -> Self {
        InstructionUnionReader::UTF8Bytes(item)
    }
}
impl InstructionUnion {
    pub const NAME: &'static str = "InstructionUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            InstructionUnion::NumberRange(item) => item.as_bytes(),
            InstructionUnion::TraitPool(item) => item.as_bytes(),
            InstructionUnion::UTF8Bytes(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            InstructionUnion::NumberRange(item) => item.as_slice(),
            InstructionUnion::TraitPool(item) => item.as_slice(),
            InstructionUnion::UTF8Bytes(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            InstructionUnion::NumberRange(_) => 0,
            InstructionUnion::TraitPool(_) => 1,
            InstructionUnion::UTF8Bytes(_) => 2,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            InstructionUnion::NumberRange(_) => "NumberRange",
            InstructionUnion::TraitPool(_) => "TraitPool",
            InstructionUnion::UTF8Bytes(_) => "UTF8Bytes",
        }
    }
    pub fn as_reader<'r>(&'r self) -> InstructionUnionReader<'r> {
        match self {
            InstructionUnion::NumberRange(item) => item.as_reader().into(),
            InstructionUnion::TraitPool(item) => item.as_reader().into(),
            InstructionUnion::UTF8Bytes(item) => item.as_reader().into(),
        }
    }
}
impl<'r> InstructionUnionReader<'r> {
    pub const NAME: &'r str = "InstructionUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            InstructionUnionReader::NumberRange(item) => item.as_slice(),
            InstructionUnionReader::TraitPool(item) => item.as_slice(),
            InstructionUnionReader::UTF8Bytes(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            InstructionUnionReader::NumberRange(_) => 0,
            InstructionUnionReader::TraitPool(_) => 1,
            InstructionUnionReader::UTF8Bytes(_) => 2,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            InstructionUnionReader::NumberRange(_) => "NumberRange",
            InstructionUnionReader::TraitPool(_) => "TraitPool",
            InstructionUnionReader::UTF8Bytes(_) => "UTF8Bytes",
        }
    }
}
impl From<NumberRange> for Instruction {
    fn from(value: NumberRange) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<TraitPool> for Instruction {
    fn from(value: TraitPool) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<UTF8Bytes> for Instruction {
    fn from(value: UTF8Bytes) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct InstructionVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for InstructionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for InstructionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for InstructionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for InstructionVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        InstructionVec::new_unchecked(v)
    }
}
impl InstructionVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Instruction> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Instruction {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Instruction::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Instruction::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> InstructionVecReader<'r> {
        InstructionVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for InstructionVec {
    type Builder = InstructionVecBuilder;
    const NAME: &'static str = "InstructionVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        InstructionVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        InstructionVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        InstructionVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct InstructionVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for InstructionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for InstructionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for InstructionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> InstructionVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<InstructionReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> InstructionReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            InstructionReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            InstructionReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for InstructionVecReader<'r> {
    type Entity = InstructionVec;
    const NAME: &'static str = "InstructionVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        InstructionVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            InstructionReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct InstructionVecBuilder(pub(crate) Vec<Instruction>);
impl InstructionVecBuilder {
    pub fn set(mut self, v: Vec<Instruction>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Instruction) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Instruction>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Instruction) -> Option<Instruction> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for InstructionVecBuilder {
    type Entity = InstructionVec;
    const NAME: &'static str = "InstructionVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        InstructionVec::new_unchecked(inner.into())
    }
}
pub struct InstructionVecIterator(InstructionVec, usize, usize);
impl ::core::iter::Iterator for InstructionVecIterator {
    type Item = Instruction;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for InstructionVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for InstructionVec {
    type Item = Instruction;
    type IntoIter = InstructionVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        InstructionVecIterator(self, 0, len)
    }
}
impl<'r> InstructionVecReader<'r> {
    pub fn iter<'t>(&'t self) -> InstructionVecReaderIterator<'t, 'r> {
        InstructionVecReaderIterator(&self, 0, self.len())
    }
}
pub struct InstructionVecReaderIterator<'t, 'r>(&'t InstructionVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for InstructionVecReaderIterator<'t, 'r> {
    type Item = InstructionReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for InstructionVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<Instruction> for InstructionVec {
    fn from_iter<T: IntoIterator<Item = Instruction>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
#[derive(Clone)]
pub struct TemplatePool(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TemplatePool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TemplatePool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TemplatePool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for TemplatePool {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TemplatePool::new_unchecked(v)
    }
}
impl TemplatePool {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<InstructionVec> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> InstructionVec {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            InstructionVec::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            InstructionVec::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TemplatePoolReader<'r> {
        TemplatePoolReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TemplatePool {
    type Builder = TemplatePoolBuilder;
    const NAME: &'static str = "TemplatePool";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TemplatePool(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TemplatePoolReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TemplatePoolReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct TemplatePoolReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TemplatePoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TemplatePoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TemplatePoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> TemplatePoolReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<InstructionVecReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> InstructionVecReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            InstructionVecReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            InstructionVecReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TemplatePoolReader<'r> {
    type Entity = TemplatePool;
    const NAME: &'static str = "TemplatePoolReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TemplatePoolReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            InstructionVecReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TemplatePoolBuilder(pub(crate) Vec<InstructionVec>);
impl TemplatePoolBuilder {
    pub fn set(mut self, v: Vec<InstructionVec>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: InstructionVec) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = InstructionVec>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: InstructionVec) -> Option<InstructionVec> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for TemplatePoolBuilder {
    type Entity = TemplatePool;
    const NAME: &'static str = "TemplatePoolBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TemplatePool::new_unchecked(inner.into())
    }
}
pub struct TemplatePoolIterator(TemplatePool, usize, usize);
impl ::core::iter::Iterator for TemplatePoolIterator {
    type Item = InstructionVec;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for TemplatePoolIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for TemplatePool {
    type Item = InstructionVec;
    type IntoIter = TemplatePoolIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        TemplatePoolIterator(self, 0, len)
    }
}
impl<'r> TemplatePoolReader<'r> {
    pub fn iter<'t>(&'t self) -> TemplatePoolReaderIterator<'t, 'r> {
        TemplatePoolReaderIterator(&self, 0, self.len())
    }
}
pub struct TemplatePoolReaderIterator<'t, 'r>(&'t TemplatePoolReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for TemplatePoolReaderIterator<'t, 'r> {
    type Item = InstructionVecReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for TemplatePoolReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<InstructionVec> for TemplatePool {
    fn from_iter<T: IntoIterator<Item = InstructionVec>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
#[derive(Clone)]
pub struct Pool(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Pool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Pool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Pool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for Pool {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Pool::new_unchecked(v)
    }
}
impl Pool {
    const DEFAULT_VALUE: [u8; 8] = [0, 0, 0, 0, 4, 0, 0, 0];
    pub const ITEMS_COUNT: usize = 4;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> PoolUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => TraitPool::new_unchecked(inner).into(),
            1 => NumberPool::new_unchecked(inner).into(),
            2 => NumberRange::new_unchecked(inner).into(),
            3 => TemplatePool::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> PoolReader<'r> {
        PoolReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Pool {
    type Builder = PoolBuilder;
    const NAME: &'static str = "Pool";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Pool(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PoolReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PoolReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct PoolReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> PoolReader<'r> {
    pub const ITEMS_COUNT: usize = 4;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> PoolUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => TraitPoolReader::new_unchecked(inner).into(),
            1 => NumberPoolReader::new_unchecked(inner).into(),
            2 => NumberRangeReader::new_unchecked(inner).into(),
            3 => TemplatePoolReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PoolReader<'r> {
    type Entity = Pool;
    const NAME: &'static str = "PoolReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PoolReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => TraitPoolReader::verify(inner_slice, compatible),
            1 => NumberPoolReader::verify(inner_slice, compatible),
            2 => NumberRangeReader::verify(inner_slice, compatible),
            3 => TemplatePoolReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct PoolBuilder(pub(crate) PoolUnion);
impl PoolBuilder {
    pub const ITEMS_COUNT: usize = 4;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<PoolUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for PoolBuilder {
    type Entity = Pool;
    const NAME: &'static str = "PoolBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Pool::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum PoolUnion {
    TraitPool(TraitPool),
    NumberPool(NumberPool),
    NumberRange(NumberRange),
    TemplatePool(TemplatePool),
}
#[derive(Debug, Clone, Copy)]
pub enum PoolUnionReader<'r> {
    TraitPool(TraitPoolReader<'r>),
    NumberPool(NumberPoolReader<'r>),
    NumberRange(NumberRangeReader<'r>),
    TemplatePool(TemplatePoolReader<'r>),
}
impl ::core::default::Default for PoolUnion {
    fn default() -> Self {
        PoolUnion::TraitPool(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for PoolUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PoolUnion::TraitPool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TraitPool::NAME, item)
            }
            PoolUnion::NumberPool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberPool::NAME, item)
            }
            PoolUnion::NumberRange(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberRange::NAME, item)
            }
            PoolUnion::TemplatePool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TemplatePool::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for PoolUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PoolUnionReader::TraitPool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TraitPool::NAME, item)
            }
            PoolUnionReader::NumberPool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberPool::NAME, item)
            }
            PoolUnionReader::NumberRange(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberRange::NAME, item)
            }
            PoolUnionReader::TemplatePool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TemplatePool::NAME, item)
            }
        }
    }
}
impl PoolUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PoolUnion::TraitPool(ref item) => write!(f, "{}", item),
            PoolUnion::NumberPool(ref item) => write!(f, "{}", item),
            PoolUnion::NumberRange(ref item) => write!(f, "{}", item),
            PoolUnion::TemplatePool(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> PoolUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PoolUnionReader::TraitPool(ref item) => write!(f, "{}", item),
            PoolUnionReader::NumberPool(ref item) => write!(f, "{}", item),
            PoolUnionReader::NumberRange(ref item) => write!(f, "{}", item),
            PoolUnionReader::TemplatePool(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<TraitPool> for PoolUnion {
    fn from(item: TraitPool) -> Self {
        PoolUnion::TraitPool(item)
    }
}
impl ::core::convert::From<NumberPool> for PoolUnion {
    fn from(item: NumberPool) -> Self {
        PoolUnion::NumberPool(item)
    }
}
impl ::core::convert::From<NumberRange> for PoolUnion {
    fn from(item: NumberRange) -> Self {
        PoolUnion::NumberRange(item)
    }
}
impl ::core::convert::From<TemplatePool> for PoolUnion {
    fn from(item: TemplatePool) -> Self {
        PoolUnion::TemplatePool(item)
    }
}
impl<'r> ::core::convert::From<TraitPoolReader<'r>> for PoolUnionReader<'r> {
    fn from(item: TraitPoolReader<'r>) -> Self {
        PoolUnionReader::TraitPool(item)
    }
}
impl<'r> ::core::convert::From<NumberPoolReader<'r>> for PoolUnionReader<'r> {
    fn from(item: NumberPoolReader<'r>) -> Self {
        PoolUnionReader::NumberPool(item)
    }
}
impl<'r> ::core::convert::From<NumberRangeReader<'r>> for PoolUnionReader<'r> {
    fn from(item: NumberRangeReader<'r>) -> Self {
        PoolUnionReader::NumberRange(item)
    }
}
impl<'r> ::core::convert::From<TemplatePoolReader<'r>> for PoolUnionReader<'r> {
    fn from(item: TemplatePoolReader<'r>) -> Self {
        PoolUnionReader::TemplatePool(item)
    }
}
impl PoolUnion {
    pub const NAME: &'static str = "PoolUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            PoolUnion::TraitPool(item) => item.as_bytes(),
            PoolUnion::NumberPool(item) => item.as_bytes(),
            PoolUnion::NumberRange(item) => item.as_bytes(),
            PoolUnion::TemplatePool(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            PoolUnion::TraitPool(item) => item.as_slice(),
            PoolUnion::NumberPool(item) => item.as_slice(),
            PoolUnion::NumberRange(item) => item.as_slice(),
            PoolUnion::TemplatePool(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            PoolUnion::TraitPool(_) => 0,
            PoolUnion::NumberPool(_) => 1,
            PoolUnion::NumberRange(_) => 2,
            PoolUnion::TemplatePool(_) => 3,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            PoolUnion::TraitPool(_) => "TraitPool",
            PoolUnion::NumberPool(_) => "NumberPool",
            PoolUnion::NumberRange(_) => "NumberRange",
            PoolUnion::TemplatePool(_) => "TemplatePool",
        }
    }
    pub fn as_reader<'r>(&'r self) -> PoolUnionReader<'r> {
        match self {
            PoolUnion::TraitPool(item) => item.as_reader().into(),
            PoolUnion::NumberPool(item) => item.as_reader().into(),
            PoolUnion::NumberRange(item) => item.as_reader().into(),
            PoolUnion::TemplatePool(item) => item.as_reader().into(),
        }
    }
}
impl<'r> PoolUnionReader<'r> {
    pub const NAME: &'r str = "PoolUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            PoolUnionReader::TraitPool(item) => item.as_slice(),
            PoolUnionReader::NumberPool(item) => item.as_slice(),
            PoolUnionReader::NumberRange(item) => item.as_slice(),
            PoolUnionReader::TemplatePool(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            PoolUnionReader::TraitPool(_) => 0,
            PoolUnionReader::NumberPool(_) => 1,
            PoolUnionReader::NumberRange(_) => 2,
            PoolUnionReader::TemplatePool(_) => 3,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            PoolUnionReader::TraitPool(_) => "TraitPool",
            PoolUnionReader::NumberPool(_) => "NumberPool",
            PoolUnionReader::NumberRange(_) => "NumberRange",
            PoolUnionReader::TemplatePool(_) => "TemplatePool",
        }
    }
}
impl From<TraitPool> for Pool {
    fn from(value: TraitPool) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<NumberPool> for Pool {
    fn from(value: NumberPool) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<NumberRange> for Pool {
    fn from(value: NumberRange) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<TemplatePool> for Pool {
    fn from(value: TemplatePool) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct Segment(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Segment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Segment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Segment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "segment_bytes", self.segment_bytes())?;
        write!(f, ", {}: {}", "pool", self.pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Segment {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Segment::new_unchecked(v)
    }
}
impl Segment {
    const DEFAULT_VALUE: [u8; 21] = [
        21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn segment_bytes(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn pool(&self) -> Pool {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Pool::new_unchecked(self.0.slice(start..end))
        } else {
            Pool::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SegmentReader<'r> {
        SegmentReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Segment {
    type Builder = SegmentBuilder;
    const NAME: &'static str = "Segment";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Segment(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SegmentReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SegmentReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .segment_bytes(self.segment_bytes())
            .pool(self.pool())
    }
}
#[derive(Clone, Copy)]
pub struct SegmentReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SegmentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SegmentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SegmentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "segment_bytes", self.segment_bytes())?;
        write!(f, ", {}: {}", "pool", self.pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SegmentReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn segment_bytes(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pool(&self) -> PoolReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            PoolReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            PoolReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SegmentReader<'r> {
    type Entity = Segment;
    const NAME: &'static str = "SegmentReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SegmentReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        PoolReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct SegmentBuilder {
    pub(crate) segment_bytes: Byte,
    pub(crate) pool: Pool,
}
impl SegmentBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn segment_bytes(mut self, v: Byte) -> Self {
        self.segment_bytes = v;
        self
    }
    pub fn pool(mut self, v: Pool) -> Self {
        self.pool = v;
        self
    }
}
impl molecule::prelude::Builder for SegmentBuilder {
    type Entity = Segment;
    const NAME: &'static str = "SegmentBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.segment_bytes.as_slice().len()
            + self.pool.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.segment_bytes.as_slice().len();
        offsets.push(total_size);
        total_size += self.pool.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.segment_bytes.as_slice())?;
        writer.write_all(self.pool.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Segment::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SegmentVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SegmentVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SegmentVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SegmentVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for SegmentVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SegmentVec::new_unchecked(v)
    }
}
impl SegmentVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Segment> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Segment {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Segment::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Segment::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SegmentVecReader<'r> {
        SegmentVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SegmentVec {
    type Builder = SegmentVecBuilder;
    const NAME: &'static str = "SegmentVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SegmentVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SegmentVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SegmentVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct SegmentVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SegmentVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SegmentVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SegmentVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> SegmentVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<SegmentReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> SegmentReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            SegmentReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            SegmentReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SegmentVecReader<'r> {
    type Entity = SegmentVec;
    const NAME: &'static str = "SegmentVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SegmentVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            SegmentReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct SegmentVecBuilder(pub(crate) Vec<Segment>);
impl SegmentVecBuilder {
    pub fn set(mut self, v: Vec<Segment>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Segment) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Segment>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Segment) -> Option<Segment> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for SegmentVecBuilder {
    type Entity = SegmentVec;
    const NAME: &'static str = "SegmentVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SegmentVec::new_unchecked(inner.into())
    }
}
pub struct SegmentVecIterator(SegmentVec, usize, usize);
impl ::core::iter::Iterator for SegmentVecIterator {
    type Item = Segment;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for SegmentVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for SegmentVec {
    type Item = Segment;
    type IntoIter = SegmentVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        SegmentVecIterator(self, 0, len)
    }
}
impl<'r> SegmentVecReader<'r> {
    pub fn iter<'t>(&'t self) -> SegmentVecReaderIterator<'t, 'r> {
        SegmentVecReaderIterator(&self, 0, self.len())
    }
}
pub struct SegmentVecReaderIterator<'t, 'r>(&'t SegmentVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for SegmentVecReaderIterator<'t, 'r> {
    type Item = SegmentReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for SegmentVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<Segment> for SegmentVec {
    fn from_iter<T: IntoIterator<Item = Segment>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
#[derive(Clone)]
pub struct VariableSegment(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for VariableSegment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for VariableSegment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for VariableSegment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "count", self.count())?;
        write!(f, ", {}: {}", "segments", self.segments())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for VariableSegment {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        VariableSegment::new_unchecked(v)
    }
}
impl VariableSegment {
    const DEFAULT_VALUE: [u8; 37] = [
        37, 0, 0, 0, 12, 0, 0, 0, 33, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0,
        0, 4, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn count(&self) -> Segment {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Segment::new_unchecked(self.0.slice(start..end))
    }
    pub fn segments(&self) -> SegmentVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            SegmentVec::new_unchecked(self.0.slice(start..end))
        } else {
            SegmentVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> VariableSegmentReader<'r> {
        VariableSegmentReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for VariableSegment {
    type Builder = VariableSegmentBuilder;
    const NAME: &'static str = "VariableSegment";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        VariableSegment(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        VariableSegmentReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        VariableSegmentReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .count(self.count())
            .segments(self.segments())
    }
}
#[derive(Clone, Copy)]
pub struct VariableSegmentReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for VariableSegmentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for VariableSegmentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for VariableSegmentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "count", self.count())?;
        write!(f, ", {}: {}", "segments", self.segments())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> VariableSegmentReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn count(&self) -> SegmentReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        SegmentReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn segments(&self) -> SegmentVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            SegmentVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            SegmentVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for VariableSegmentReader<'r> {
    type Entity = VariableSegment;
    const NAME: &'static str = "VariableSegmentReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        VariableSegmentReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        SegmentReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        SegmentVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct VariableSegmentBuilder {
    pub(crate) count: Segment,
    pub(crate) segments: SegmentVec,
}
impl VariableSegmentBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn count(mut self, v: Segment) -> Self {
        self.count = v;
        self
    }
    pub fn segments(mut self, v: SegmentVec) -> Self {
        self.segments = v;
        self
    }
}
impl molecule::prelude::Builder for VariableSegmentBuilder {
    type Entity = VariableSegment;
    const NAME: &'static str = "VariableSegmentBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.count.as_slice().len()
            + self.segments.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.count.as_slice().len();
        offsets.push(total_size);
        total_size += self.segments.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.count.as_slice())?;
        writer.write_all(self.segments.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        VariableSegment::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct VariableSegmentVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for VariableSegmentVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for VariableSegmentVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for VariableSegmentVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for VariableSegmentVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        VariableSegmentVec::new_unchecked(v)
    }
}
impl VariableSegmentVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<VariableSegment> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> VariableSegment {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            VariableSegment::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            VariableSegment::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> VariableSegmentVecReader<'r> {
        VariableSegmentVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for VariableSegmentVec {
    type Builder = VariableSegmentVecBuilder;
    const NAME: &'static str = "VariableSegmentVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        VariableSegmentVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        VariableSegmentVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        VariableSegmentVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct VariableSegmentVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for VariableSegmentVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for VariableSegmentVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for VariableSegmentVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> VariableSegmentVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<VariableSegmentReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> VariableSegmentReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            VariableSegmentReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            VariableSegmentReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for VariableSegmentVecReader<'r> {
    type Entity = VariableSegmentVec;
    const NAME: &'static str = "VariableSegmentVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        VariableSegmentVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            VariableSegmentReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct VariableSegmentVecBuilder(pub(crate) Vec<VariableSegment>);
impl VariableSegmentVecBuilder {
    pub fn set(mut self, v: Vec<VariableSegment>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: VariableSegment) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = VariableSegment>>(
        mut self,
        iter: T,
    ) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: VariableSegment) -> Option<VariableSegment> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for VariableSegmentVecBuilder {
    type Entity = VariableSegmentVec;
    const NAME: &'static str = "VariableSegmentVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        VariableSegmentVec::new_unchecked(inner.into())
    }
}
pub struct VariableSegmentVecIterator(VariableSegmentVec, usize, usize);
impl ::core::iter::Iterator for VariableSegmentVecIterator {
    type Item = VariableSegment;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for VariableSegmentVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for VariableSegmentVec {
    type Item = VariableSegment;
    type IntoIter = VariableSegmentVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        VariableSegmentVecIterator(self, 0, len)
    }
}
impl<'r> VariableSegmentVecReader<'r> {
    pub fn iter<'t>(&'t self) -> VariableSegmentVecReaderIterator<'t, 'r> {
        VariableSegmentVecReaderIterator(&self, 0, self.len())
    }
}
pub struct VariableSegmentVecReaderIterator<'t, 'r>(&'t VariableSegmentVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for VariableSegmentVecReaderIterator<'t, 'r> {
    type Item = VariableSegmentReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for VariableSegmentVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<VariableSegment> for VariableSegmentVec {
    fn from_iter<T: IntoIterator<Item = VariableSegment>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
#[derive(Clone)]
pub struct Pattern(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Pattern {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Pattern {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Pattern {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for Pattern {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Pattern::new_unchecked(v)
    }
}
impl Pattern {
    const DEFAULT_VALUE: [u8; 25] = [
        0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 3;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> PatternUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => Segment::new_unchecked(inner).into(),
            1 => VariableSegment::new_unchecked(inner).into(),
            2 => VariableSegmentVec::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> PatternReader<'r> {
        PatternReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Pattern {
    type Builder = PatternBuilder;
    const NAME: &'static str = "Pattern";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Pattern(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PatternReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PatternReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct PatternReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PatternReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PatternReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PatternReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> PatternReader<'r> {
    pub const ITEMS_COUNT: usize = 3;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> PatternUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => SegmentReader::new_unchecked(inner).into(),
            1 => VariableSegmentReader::new_unchecked(inner).into(),
            2 => VariableSegmentVecReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PatternReader<'r> {
    type Entity = Pattern;
    const NAME: &'static str = "PatternReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PatternReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => SegmentReader::verify(inner_slice, compatible),
            1 => VariableSegmentReader::verify(inner_slice, compatible),
            2 => VariableSegmentVecReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct PatternBuilder(pub(crate) PatternUnion);
impl PatternBuilder {
    pub const ITEMS_COUNT: usize = 3;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<PatternUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for PatternBuilder {
    type Entity = Pattern;
    const NAME: &'static str = "PatternBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Pattern::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum PatternUnion {
    Segment(Segment),
    VariableSegment(VariableSegment),
    VariableSegmentVec(VariableSegmentVec),
}
#[derive(Debug, Clone, Copy)]
pub enum PatternUnionReader<'r> {
    Segment(SegmentReader<'r>),
    VariableSegment(VariableSegmentReader<'r>),
    VariableSegmentVec(VariableSegmentVecReader<'r>),
}
impl ::core::default::Default for PatternUnion {
    fn default() -> Self {
        PatternUnion::Segment(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for PatternUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PatternUnion::Segment(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Segment::NAME, item)
            }
            PatternUnion::VariableSegment(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, VariableSegment::NAME, item)
            }
            PatternUnion::VariableSegmentVec(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, VariableSegmentVec::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for PatternUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PatternUnionReader::Segment(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Segment::NAME, item)
            }
            PatternUnionReader::VariableSegment(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, VariableSegment::NAME, item)
            }
            PatternUnionReader::VariableSegmentVec(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, VariableSegmentVec::NAME, item)
            }
        }
    }
}
impl PatternUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PatternUnion::Segment(ref item) => write!(f, "{}", item),
            PatternUnion::VariableSegment(ref item) => write!(f, "{}", item),
            PatternUnion::VariableSegmentVec(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> PatternUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PatternUnionReader::Segment(ref item) => write!(f, "{}", item),
            PatternUnionReader::VariableSegment(ref item) => write!(f, "{}", item),
            PatternUnionReader::VariableSegmentVec(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<Segment> for PatternUnion {
    fn from(item: Segment) -> Self {
        PatternUnion::Segment(item)
    }
}
impl ::core::convert::From<VariableSegment> for PatternUnion {
    fn from(item: VariableSegment) -> Self {
        PatternUnion::VariableSegment(item)
    }
}
impl ::core::convert::From<VariableSegmentVec> for PatternUnion {
    fn from(item: VariableSegmentVec) -> Self {
        PatternUnion::VariableSegmentVec(item)
    }
}
impl<'r> ::core::convert::From<SegmentReader<'r>> for PatternUnionReader<'r> {
    fn from(item: SegmentReader<'r>) -> Self {
        PatternUnionReader::Segment(item)
    }
}
impl<'r> ::core::convert::From<VariableSegmentReader<'r>> for PatternUnionReader<'r> {
    fn from(item: VariableSegmentReader<'r>) -> Self {
        PatternUnionReader::VariableSegment(item)
    }
}
impl<'r> ::core::convert::From<VariableSegmentVecReader<'r>> for PatternUnionReader<'r> {
    fn from(item: VariableSegmentVecReader<'r>) -> Self {
        PatternUnionReader::VariableSegmentVec(item)
    }
}
impl PatternUnion {
    pub const NAME: &'static str = "PatternUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            PatternUnion::Segment(item) => item.as_bytes(),
            PatternUnion::VariableSegment(item) => item.as_bytes(),
            PatternUnion::VariableSegmentVec(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            PatternUnion::Segment(item) => item.as_slice(),
            PatternUnion::VariableSegment(item) => item.as_slice(),
            PatternUnion::VariableSegmentVec(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            PatternUnion::Segment(_) => 0,
            PatternUnion::VariableSegment(_) => 1,
            PatternUnion::VariableSegmentVec(_) => 2,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            PatternUnion::Segment(_) => "Segment",
            PatternUnion::VariableSegment(_) => "VariableSegment",
            PatternUnion::VariableSegmentVec(_) => "VariableSegmentVec",
        }
    }
    pub fn as_reader<'r>(&'r self) -> PatternUnionReader<'r> {
        match self {
            PatternUnion::Segment(item) => item.as_reader().into(),
            PatternUnion::VariableSegment(item) => item.as_reader().into(),
            PatternUnion::VariableSegmentVec(item) => item.as_reader().into(),
        }
    }
}
impl<'r> PatternUnionReader<'r> {
    pub const NAME: &'r str = "PatternUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            PatternUnionReader::Segment(item) => item.as_slice(),
            PatternUnionReader::VariableSegment(item) => item.as_slice(),
            PatternUnionReader::VariableSegmentVec(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            PatternUnionReader::Segment(_) => 0,
            PatternUnionReader::VariableSegment(_) => 1,
            PatternUnionReader::VariableSegmentVec(_) => 2,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            PatternUnionReader::Segment(_) => "Segment",
            PatternUnionReader::VariableSegment(_) => "VariableSegment",
            PatternUnionReader::VariableSegmentVec(_) => "VariableSegmentVec",
        }
    }
}
impl From<Segment> for Pattern {
    fn from(value: Segment) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<VariableSegment> for Pattern {
    fn from(value: VariableSegment) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<VariableSegmentVec> for Pattern {
    fn from(value: VariableSegmentVec) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct PlayerSchema(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for PlayerSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for PlayerSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for PlayerSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "adjective", self.adjective())?;
        write!(f, ", {}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "profession", self.profession())?;
        write!(f, ", {}: {}", "power", self.power())?;
        write!(f, ", {}: {}", "gold", self.gold())?;
        write!(f, ", {}: {}", "card", self.card())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for PlayerSchema {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        PlayerSchema::new_unchecked(v)
    }
}
impl PlayerSchema {
    const DEFAULT_VALUE: [u8; 178] = [
        178, 0, 0, 0, 28, 0, 0, 0, 53, 0, 0, 0, 78, 0, 0, 0, 103, 0, 0, 0, 128, 0, 0, 0, 153, 0, 0,
        0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0,
        0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0,
        0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0,
        0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0,
        0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0,
        0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn adjective(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn name(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn profession(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn power(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn gold(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn card(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Pattern::new_unchecked(self.0.slice(start..end))
        } else {
            Pattern::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> PlayerSchemaReader<'r> {
        PlayerSchemaReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for PlayerSchema {
    type Builder = PlayerSchemaBuilder;
    const NAME: &'static str = "PlayerSchema";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PlayerSchema(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PlayerSchemaReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PlayerSchemaReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .adjective(self.adjective())
            .name(self.name())
            .profession(self.profession())
            .power(self.power())
            .gold(self.gold())
            .card(self.card())
    }
}
#[derive(Clone, Copy)]
pub struct PlayerSchemaReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PlayerSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PlayerSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PlayerSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "adjective", self.adjective())?;
        write!(f, ", {}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "profession", self.profession())?;
        write!(f, ", {}: {}", "power", self.power())?;
        write!(f, ", {}: {}", "gold", self.gold())?;
        write!(f, ", {}: {}", "card", self.card())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> PlayerSchemaReader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn adjective(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn name(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn profession(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn power(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn gold(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn card(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            PatternReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            PatternReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PlayerSchemaReader<'r> {
    type Entity = PlayerSchema;
    const NAME: &'static str = "PlayerSchemaReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PlayerSchemaReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        PatternReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        PatternReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        PatternReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        PatternReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        PatternReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        PatternReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct PlayerSchemaBuilder {
    pub(crate) adjective: Pattern,
    pub(crate) name: Pattern,
    pub(crate) profession: Pattern,
    pub(crate) power: Pattern,
    pub(crate) gold: Pattern,
    pub(crate) card: Pattern,
}
impl PlayerSchemaBuilder {
    pub const FIELD_COUNT: usize = 6;
    pub fn adjective(mut self, v: Pattern) -> Self {
        self.adjective = v;
        self
    }
    pub fn name(mut self, v: Pattern) -> Self {
        self.name = v;
        self
    }
    pub fn profession(mut self, v: Pattern) -> Self {
        self.profession = v;
        self
    }
    pub fn power(mut self, v: Pattern) -> Self {
        self.power = v;
        self
    }
    pub fn gold(mut self, v: Pattern) -> Self {
        self.gold = v;
        self
    }
    pub fn card(mut self, v: Pattern) -> Self {
        self.card = v;
        self
    }
}
impl molecule::prelude::Builder for PlayerSchemaBuilder {
    type Entity = PlayerSchema;
    const NAME: &'static str = "PlayerSchemaBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.adjective.as_slice().len()
            + self.name.as_slice().len()
            + self.profession.as_slice().len()
            + self.power.as_slice().len()
            + self.gold.as_slice().len()
            + self.card.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.adjective.as_slice().len();
        offsets.push(total_size);
        total_size += self.name.as_slice().len();
        offsets.push(total_size);
        total_size += self.profession.as_slice().len();
        offsets.push(total_size);
        total_size += self.power.as_slice().len();
        offsets.push(total_size);
        total_size += self.gold.as_slice().len();
        offsets.push(total_size);
        total_size += self.card.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.adjective.as_slice())?;
        writer.write_all(self.name.as_slice())?;
        writer.write_all(self.profession.as_slice())?;
        writer.write_all(self.power.as_slice())?;
        writer.write_all(self.gold.as_slice())?;
        writer.write_all(self.card.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        PlayerSchema::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SceneSchema(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SceneSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SceneSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SceneSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "attribute", self.attribute())?;
        write!(f, ", {}: {}", "operation", self.operation())?;
        write!(f, ", {}: {}", "difficulty", self.difficulty())?;
        write!(f, ", {}: {}", "score", self.score())?;
        write!(f, ", {}: {}", "commodity", self.commodity())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SceneSchema {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SceneSchema::new_unchecked(v)
    }
}
impl SceneSchema {
    const DEFAULT_VALUE: [u8; 178] = [
        178, 0, 0, 0, 28, 0, 0, 0, 53, 0, 0, 0, 78, 0, 0, 0, 103, 0, 0, 0, 128, 0, 0, 0, 153, 0, 0,
        0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0,
        0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0,
        0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0,
        0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0,
        0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0,
        0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn name(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn attribute(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn operation(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn difficulty(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn score(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn commodity(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Pattern::new_unchecked(self.0.slice(start..end))
        } else {
            Pattern::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SceneSchemaReader<'r> {
        SceneSchemaReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SceneSchema {
    type Builder = SceneSchemaBuilder;
    const NAME: &'static str = "SceneSchema";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SceneSchema(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SceneSchemaReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SceneSchemaReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .name(self.name())
            .attribute(self.attribute())
            .operation(self.operation())
            .difficulty(self.difficulty())
            .score(self.score())
            .commodity(self.commodity())
    }
}
#[derive(Clone, Copy)]
pub struct SceneSchemaReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SceneSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SceneSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SceneSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "attribute", self.attribute())?;
        write!(f, ", {}: {}", "operation", self.operation())?;
        write!(f, ", {}: {}", "difficulty", self.difficulty())?;
        write!(f, ", {}: {}", "score", self.score())?;
        write!(f, ", {}: {}", "commodity", self.commodity())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SceneSchemaReader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn name(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn attribute(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn operation(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn difficulty(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn score(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn commodity(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            PatternReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            PatternReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SceneSchemaReader<'r> {
    type Entity = SceneSchema;
    const NAME: &'static str = "SceneSchemaReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SceneSchemaReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        PatternReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        PatternReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        PatternReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        PatternReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        PatternReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        PatternReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct SceneSchemaBuilder {
    pub(crate) name: Pattern,
    pub(crate) attribute: Pattern,
    pub(crate) operation: Pattern,
    pub(crate) difficulty: Pattern,
    pub(crate) score: Pattern,
    pub(crate) commodity: Pattern,
}
impl SceneSchemaBuilder {
    pub const FIELD_COUNT: usize = 6;
    pub fn name(mut self, v: Pattern) -> Self {
        self.name = v;
        self
    }
    pub fn attribute(mut self, v: Pattern) -> Self {
        self.attribute = v;
        self
    }
    pub fn operation(mut self, v: Pattern) -> Self {
        self.operation = v;
        self
    }
    pub fn difficulty(mut self, v: Pattern) -> Self {
        self.difficulty = v;
        self
    }
    pub fn score(mut self, v: Pattern) -> Self {
        self.score = v;
        self
    }
    pub fn commodity(mut self, v: Pattern) -> Self {
        self.commodity = v;
        self
    }
}
impl molecule::prelude::Builder for SceneSchemaBuilder {
    type Entity = SceneSchema;
    const NAME: &'static str = "SceneSchemaBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.name.as_slice().len()
            + self.attribute.as_slice().len()
            + self.operation.as_slice().len()
            + self.difficulty.as_slice().len()
            + self.score.as_slice().len()
            + self.commodity.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.name.as_slice().len();
        offsets.push(total_size);
        total_size += self.attribute.as_slice().len();
        offsets.push(total_size);
        total_size += self.operation.as_slice().len();
        offsets.push(total_size);
        total_size += self.difficulty.as_slice().len();
        offsets.push(total_size);
        total_size += self.score.as_slice().len();
        offsets.push(total_size);
        total_size += self.commodity.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.name.as_slice())?;
        writer.write_all(self.attribute.as_slice())?;
        writer.write_all(self.operation.as_slice())?;
        writer.write_all(self.difficulty.as_slice())?;
        writer.write_all(self.score.as_slice())?;
        writer.write_all(self.commodity.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SceneSchema::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct EnvironmentSchema(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for EnvironmentSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for EnvironmentSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for EnvironmentSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "adjective", self.adjective())?;
        write!(f, ", {}: {}", "era", self.era())?;
        write!(f, ", {}: {}", "time", self.time())?;
        write!(f, ", {}: {}", "mode", self.mode())?;
        write!(f, ", {}: {}", "rank", self.rank())?;
        write!(f, ", {}: {}", "effect", self.effect())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for EnvironmentSchema {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        EnvironmentSchema::new_unchecked(v)
    }
}
impl EnvironmentSchema {
    const DEFAULT_VALUE: [u8; 178] = [
        178, 0, 0, 0, 28, 0, 0, 0, 53, 0, 0, 0, 78, 0, 0, 0, 103, 0, 0, 0, 128, 0, 0, 0, 153, 0, 0,
        0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0,
        0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0,
        0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0,
        0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0,
        0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0,
        0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn adjective(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn era(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn time(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn mode(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn rank(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn effect(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Pattern::new_unchecked(self.0.slice(start..end))
        } else {
            Pattern::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> EnvironmentSchemaReader<'r> {
        EnvironmentSchemaReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for EnvironmentSchema {
    type Builder = EnvironmentSchemaBuilder;
    const NAME: &'static str = "EnvironmentSchema";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        EnvironmentSchema(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        EnvironmentSchemaReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        EnvironmentSchemaReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .adjective(self.adjective())
            .era(self.era())
            .time(self.time())
            .mode(self.mode())
            .rank(self.rank())
            .effect(self.effect())
    }
}
#[derive(Clone, Copy)]
pub struct EnvironmentSchemaReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for EnvironmentSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for EnvironmentSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for EnvironmentSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "adjective", self.adjective())?;
        write!(f, ", {}: {}", "era", self.era())?;
        write!(f, ", {}: {}", "time", self.time())?;
        write!(f, ", {}: {}", "mode", self.mode())?;
        write!(f, ", {}: {}", "rank", self.rank())?;
        write!(f, ", {}: {}", "effect", self.effect())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> EnvironmentSchemaReader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn adjective(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn era(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn time(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn mode(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn rank(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn effect(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            PatternReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            PatternReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for EnvironmentSchemaReader<'r> {
    type Entity = EnvironmentSchema;
    const NAME: &'static str = "EnvironmentSchemaReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        EnvironmentSchemaReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        PatternReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        PatternReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        PatternReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        PatternReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        PatternReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        PatternReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct EnvironmentSchemaBuilder {
    pub(crate) adjective: Pattern,
    pub(crate) era: Pattern,
    pub(crate) time: Pattern,
    pub(crate) mode: Pattern,
    pub(crate) rank: Pattern,
    pub(crate) effect: Pattern,
}
impl EnvironmentSchemaBuilder {
    pub const FIELD_COUNT: usize = 6;
    pub fn adjective(mut self, v: Pattern) -> Self {
        self.adjective = v;
        self
    }
    pub fn era(mut self, v: Pattern) -> Self {
        self.era = v;
        self
    }
    pub fn time(mut self, v: Pattern) -> Self {
        self.time = v;
        self
    }
    pub fn mode(mut self, v: Pattern) -> Self {
        self.mode = v;
        self
    }
    pub fn rank(mut self, v: Pattern) -> Self {
        self.rank = v;
        self
    }
    pub fn effect(mut self, v: Pattern) -> Self {
        self.effect = v;
        self
    }
}
impl molecule::prelude::Builder for EnvironmentSchemaBuilder {
    type Entity = EnvironmentSchema;
    const NAME: &'static str = "EnvironmentSchemaBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.adjective.as_slice().len()
            + self.era.as_slice().len()
            + self.time.as_slice().len()
            + self.mode.as_slice().len()
            + self.rank.as_slice().len()
            + self.effect.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.adjective.as_slice().len();
        offsets.push(total_size);
        total_size += self.era.as_slice().len();
        offsets.push(total_size);
        total_size += self.time.as_slice().len();
        offsets.push(total_size);
        total_size += self.mode.as_slice().len();
        offsets.push(total_size);
        total_size += self.rank.as_slice().len();
        offsets.push(total_size);
        total_size += self.effect.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.adjective.as_slice())?;
        writer.write_all(self.era.as_slice())?;
        writer.write_all(self.time.as_slice())?;
        writer.write_all(self.mode.as_slice())?;
        writer.write_all(self.rank.as_slice())?;
        writer.write_all(self.effect.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        EnvironmentSchema::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChronicleSchema(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChronicleSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChronicleSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChronicleSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "player", self.player())?;
        write!(f, ", {}: {}", "scene", self.scene())?;
        write!(f, ", {}: {}", "environment", self.environment())?;
        write!(f, ", {}: {}", "transition", self.transition())?;
        write!(f, ", {}: {}", "climax", self.climax())?;
        write!(f, ", {}: {}", "ending", self.ending())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChronicleSchema {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ChronicleSchema::new_unchecked(v)
    }
}
impl ChronicleSchema {
    const DEFAULT_VALUE: [u8; 178] = [
        178, 0, 0, 0, 28, 0, 0, 0, 53, 0, 0, 0, 78, 0, 0, 0, 103, 0, 0, 0, 128, 0, 0, 0, 153, 0, 0,
        0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0,
        0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0,
        0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0,
        0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0,
        0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0,
        0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn player(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn scene(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn environment(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn transition(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn climax(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Pattern::new_unchecked(self.0.slice(start..end))
    }
    pub fn ending(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Pattern::new_unchecked(self.0.slice(start..end))
        } else {
            Pattern::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChronicleSchemaReader<'r> {
        ChronicleSchemaReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChronicleSchema {
    type Builder = ChronicleSchemaBuilder;
    const NAME: &'static str = "ChronicleSchema";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChronicleSchema(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChronicleSchemaReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChronicleSchemaReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .player(self.player())
            .scene(self.scene())
            .environment(self.environment())
            .transition(self.transition())
            .climax(self.climax())
            .ending(self.ending())
    }
}
#[derive(Clone, Copy)]
pub struct ChronicleSchemaReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChronicleSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChronicleSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChronicleSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "player", self.player())?;
        write!(f, ", {}: {}", "scene", self.scene())?;
        write!(f, ", {}: {}", "environment", self.environment())?;
        write!(f, ", {}: {}", "transition", self.transition())?;
        write!(f, ", {}: {}", "climax", self.climax())?;
        write!(f, ", {}: {}", "ending", self.ending())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ChronicleSchemaReader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn player(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn scene(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn environment(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transition(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn climax(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        PatternReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn ending(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            PatternReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            PatternReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChronicleSchemaReader<'r> {
    type Entity = ChronicleSchema;
    const NAME: &'static str = "ChronicleSchemaReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChronicleSchemaReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        PatternReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        PatternReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        PatternReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        PatternReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        PatternReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        PatternReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ChronicleSchemaBuilder {
    pub(crate) player: Pattern,
    pub(crate) scene: Pattern,
    pub(crate) environment: Pattern,
    pub(crate) transition: Pattern,
    pub(crate) climax: Pattern,
    pub(crate) ending: Pattern,
}
impl ChronicleSchemaBuilder {
    pub const FIELD_COUNT: usize = 6;
    pub fn player(mut self, v: Pattern) -> Self {
        self.player = v;
        self
    }
    pub fn scene(mut self, v: Pattern) -> Self {
        self.scene = v;
        self
    }
    pub fn environment(mut self, v: Pattern) -> Self {
        self.environment = v;
        self
    }
    pub fn transition(mut self, v: Pattern) -> Self {
        self.transition = v;
        self
    }
    pub fn climax(mut self, v: Pattern) -> Self {
        self.climax = v;
        self
    }
    pub fn ending(mut self, v: Pattern) -> Self {
        self.ending = v;
        self
    }
}
impl molecule::prelude::Builder for ChronicleSchemaBuilder {
    type Entity = ChronicleSchema;
    const NAME: &'static str = "ChronicleSchemaBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.player.as_slice().len()
            + self.scene.as_slice().len()
            + self.environment.as_slice().len()
            + self.transition.as_slice().len()
            + self.climax.as_slice().len()
            + self.ending.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.player.as_slice().len();
        offsets.push(total_size);
        total_size += self.scene.as_slice().len();
        offsets.push(total_size);
        total_size += self.environment.as_slice().len();
        offsets.push(total_size);
        total_size += self.transition.as_slice().len();
        offsets.push(total_size);
        total_size += self.climax.as_slice().len();
        offsets.push(total_size);
        total_size += self.ending.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.player.as_slice())?;
        writer.write_all(self.scene.as_slice())?;
        writer.write_all(self.environment.as_slice())?;
        writer.write_all(self.transition.as_slice())?;
        writer.write_all(self.climax.as_slice())?;
        writer.write_all(self.ending.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChronicleSchema::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct AshWarChronicle(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for AshWarChronicle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for AshWarChronicle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for AshWarChronicle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "player", self.player())?;
        write!(f, ", {}: {}", "scene", self.scene())?;
        write!(f, ", {}: {}", "envionment", self.envionment())?;
        write!(f, ", {}: {}", "chronicle", self.chronicle())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for AshWarChronicle {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        AshWarChronicle::new_unchecked(v)
    }
}
impl AshWarChronicle {
    const DEFAULT_VALUE: [u8; 732] = [
        220, 2, 0, 0, 20, 0, 0, 0, 198, 0, 0, 0, 120, 1, 0, 0, 42, 2, 0, 0, 178, 0, 0, 0, 28, 0, 0,
        0, 53, 0, 0, 0, 78, 0, 0, 0, 103, 0, 0, 0, 128, 0, 0, 0, 153, 0, 0, 0, 0, 0, 0, 0, 21, 0,
        0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0,
        0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0,
        0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0,
        0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4,
        0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 178,
        0, 0, 0, 28, 0, 0, 0, 53, 0, 0, 0, 78, 0, 0, 0, 103, 0, 0, 0, 128, 0, 0, 0, 153, 0, 0, 0,
        0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0,
        21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0,
        12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0,
        13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0,
        0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0,
        0, 4, 0, 0, 0, 178, 0, 0, 0, 28, 0, 0, 0, 53, 0, 0, 0, 78, 0, 0, 0, 103, 0, 0, 0, 128, 0,
        0, 0, 153, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,
        0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0,
        0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0,
        0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0,
        0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0,
        0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 178, 0, 0, 0, 28, 0, 0, 0, 53, 0, 0, 0, 78, 0, 0, 0, 103,
        0, 0, 0, 128, 0, 0, 0, 153, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0,
        0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0,
        4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
        0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0,
        21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0,
        12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn player(&self) -> PlayerSchema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        PlayerSchema::new_unchecked(self.0.slice(start..end))
    }
    pub fn scene(&self) -> SceneSchema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        SceneSchema::new_unchecked(self.0.slice(start..end))
    }
    pub fn envionment(&self) -> EnvironmentSchema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        EnvironmentSchema::new_unchecked(self.0.slice(start..end))
    }
    pub fn chronicle(&self) -> ChronicleSchema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            ChronicleSchema::new_unchecked(self.0.slice(start..end))
        } else {
            ChronicleSchema::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> AshWarChronicleReader<'r> {
        AshWarChronicleReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for AshWarChronicle {
    type Builder = AshWarChronicleBuilder;
    const NAME: &'static str = "AshWarChronicle";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        AshWarChronicle(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AshWarChronicleReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AshWarChronicleReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .player(self.player())
            .scene(self.scene())
            .envionment(self.envionment())
            .chronicle(self.chronicle())
    }
}
#[derive(Clone, Copy)]
pub struct AshWarChronicleReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AshWarChronicleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AshWarChronicleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AshWarChronicleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "player", self.player())?;
        write!(f, ", {}: {}", "scene", self.scene())?;
        write!(f, ", {}: {}", "envionment", self.envionment())?;
        write!(f, ", {}: {}", "chronicle", self.chronicle())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> AshWarChronicleReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn player(&self) -> PlayerSchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        PlayerSchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn scene(&self) -> SceneSchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        SceneSchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn envionment(&self) -> EnvironmentSchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        EnvironmentSchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn chronicle(&self) -> ChronicleSchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            ChronicleSchemaReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ChronicleSchemaReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AshWarChronicleReader<'r> {
    type Entity = AshWarChronicle;
    const NAME: &'static str = "AshWarChronicleReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AshWarChronicleReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        PlayerSchemaReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        SceneSchemaReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        EnvironmentSchemaReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        ChronicleSchemaReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct AshWarChronicleBuilder {
    pub(crate) player: PlayerSchema,
    pub(crate) scene: SceneSchema,
    pub(crate) envionment: EnvironmentSchema,
    pub(crate) chronicle: ChronicleSchema,
}
impl AshWarChronicleBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn player(mut self, v: PlayerSchema) -> Self {
        self.player = v;
        self
    }
    pub fn scene(mut self, v: SceneSchema) -> Self {
        self.scene = v;
        self
    }
    pub fn envionment(mut self, v: EnvironmentSchema) -> Self {
        self.envionment = v;
        self
    }
    pub fn chronicle(mut self, v: ChronicleSchema) -> Self {
        self.chronicle = v;
        self
    }
}
impl molecule::prelude::Builder for AshWarChronicleBuilder {
    type Entity = AshWarChronicle;
    const NAME: &'static str = "AshWarChronicleBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.player.as_slice().len()
            + self.scene.as_slice().len()
            + self.envionment.as_slice().len()
            + self.chronicle.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.player.as_slice().len();
        offsets.push(total_size);
        total_size += self.scene.as_slice().len();
        offsets.push(total_size);
        total_size += self.envionment.as_slice().len();
        offsets.push(total_size);
        total_size += self.chronicle.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.player.as_slice())?;
        writer.write_all(self.scene.as_slice())?;
        writer.write_all(self.envionment.as_slice())?;
        writer.write_all(self.chronicle.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        AshWarChronicle::new_unchecked(inner.into())
    }
}
