// Generated by Molecule 0.8.0
#![allow(unused)]

use molecule::prelude::*;
#[derive(Clone)]
pub struct UTF8Bytes(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for UTF8Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for UTF8Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for UTF8Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for UTF8Bytes {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        UTF8Bytes::new_unchecked(v)
    }
}
impl UTF8Bytes {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice(molecule::NUMBER_SIZE..)
    }
    pub fn as_reader<'r>(&'r self) -> UTF8BytesReader<'r> {
        UTF8BytesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for UTF8Bytes {
    type Builder = UTF8BytesBuilder;
    const NAME: &'static str = "UTF8Bytes";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        UTF8Bytes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UTF8BytesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UTF8BytesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct UTF8BytesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for UTF8BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for UTF8BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for UTF8BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> UTF8BytesReader<'r> {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[molecule::NUMBER_SIZE..]
    }
}
impl<'r> molecule::prelude::Reader<'r> for UTF8BytesReader<'r> {
    type Entity = UTF8Bytes;
    const NAME: &'static str = "UTF8BytesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        UTF8BytesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct UTF8BytesBuilder(pub(crate) Vec<Byte>);
impl UTF8BytesBuilder {
    pub const ITEM_SIZE: usize = 1;
    pub fn set(mut self, v: Vec<Byte>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Byte) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Byte) -> Option<Byte> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for UTF8BytesBuilder {
    type Entity = UTF8Bytes;
    const NAME: &'static str = "UTF8BytesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        UTF8Bytes::new_unchecked(inner.into())
    }
}
pub struct UTF8BytesIterator(UTF8Bytes, usize, usize);
impl ::core::iter::Iterator for UTF8BytesIterator {
    type Item = Byte;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for UTF8BytesIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for UTF8Bytes {
    type Item = Byte;
    type IntoIter = UTF8BytesIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        UTF8BytesIterator(self, 0, len)
    }
}
impl ::core::iter::FromIterator<Byte> for UTF8Bytes {
    fn from_iter<T: IntoIterator<Item = Byte>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
impl ::core::iter::FromIterator<u8> for UTF8Bytes {
    fn from_iter<T: IntoIterator<Item = u8>>(iter: T) -> Self {
        Self::new_builder()
            .extend(iter.into_iter().map(Into::into))
            .build()
    }
}
#[derive(Clone)]
pub struct TraitPool(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TraitPool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TraitPool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TraitPool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for TraitPool {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TraitPool::new_unchecked(v)
    }
}
impl TraitPool {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<UTF8Bytes> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> UTF8Bytes {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            UTF8Bytes::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            UTF8Bytes::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TraitPoolReader<'r> {
        TraitPoolReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TraitPool {
    type Builder = TraitPoolBuilder;
    const NAME: &'static str = "TraitPool";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TraitPool(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitPoolReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TraitPoolReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct TraitPoolReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TraitPoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TraitPoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TraitPoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> TraitPoolReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<UTF8BytesReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> UTF8BytesReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            UTF8BytesReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            UTF8BytesReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TraitPoolReader<'r> {
    type Entity = TraitPool;
    const NAME: &'static str = "TraitPoolReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TraitPoolReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            UTF8BytesReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TraitPoolBuilder(pub(crate) Vec<UTF8Bytes>);
impl TraitPoolBuilder {
    pub fn set(mut self, v: Vec<UTF8Bytes>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: UTF8Bytes) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = UTF8Bytes>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: UTF8Bytes) -> Option<UTF8Bytes> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for TraitPoolBuilder {
    type Entity = TraitPool;
    const NAME: &'static str = "TraitPoolBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TraitPool::new_unchecked(inner.into())
    }
}
pub struct TraitPoolIterator(TraitPool, usize, usize);
impl ::core::iter::Iterator for TraitPoolIterator {
    type Item = UTF8Bytes;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for TraitPoolIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for TraitPool {
    type Item = UTF8Bytes;
    type IntoIter = TraitPoolIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        TraitPoolIterator(self, 0, len)
    }
}
impl<'r> TraitPoolReader<'r> {
    pub fn iter<'t>(&'t self) -> TraitPoolReaderIterator<'t, 'r> {
        TraitPoolReaderIterator(&self, 0, self.len())
    }
}
pub struct TraitPoolReaderIterator<'t, 'r>(&'t TraitPoolReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for TraitPoolReaderIterator<'t, 'r> {
    type Item = UTF8BytesReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for TraitPoolReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<UTF8Bytes> for TraitPool {
    fn from_iter<T: IntoIterator<Item = UTF8Bytes>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
#[derive(Clone)]
pub struct NumberPool(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for NumberPool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for NumberPool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for NumberPool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for NumberPool {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        NumberPool::new_unchecked(v)
    }
}
impl NumberPool {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice(molecule::NUMBER_SIZE..)
    }
    pub fn as_reader<'r>(&'r self) -> NumberPoolReader<'r> {
        NumberPoolReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for NumberPool {
    type Builder = NumberPoolBuilder;
    const NAME: &'static str = "NumberPool";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        NumberPool(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberPoolReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberPoolReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct NumberPoolReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for NumberPoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for NumberPoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for NumberPoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> NumberPoolReader<'r> {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[molecule::NUMBER_SIZE..]
    }
}
impl<'r> molecule::prelude::Reader<'r> for NumberPoolReader<'r> {
    type Entity = NumberPool;
    const NAME: &'static str = "NumberPoolReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NumberPoolReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct NumberPoolBuilder(pub(crate) Vec<Byte>);
impl NumberPoolBuilder {
    pub const ITEM_SIZE: usize = 1;
    pub fn set(mut self, v: Vec<Byte>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Byte) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Byte) -> Option<Byte> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for NumberPoolBuilder {
    type Entity = NumberPool;
    const NAME: &'static str = "NumberPoolBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        NumberPool::new_unchecked(inner.into())
    }
}
pub struct NumberPoolIterator(NumberPool, usize, usize);
impl ::core::iter::Iterator for NumberPoolIterator {
    type Item = Byte;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for NumberPoolIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for NumberPool {
    type Item = Byte;
    type IntoIter = NumberPoolIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        NumberPoolIterator(self, 0, len)
    }
}
impl ::core::iter::FromIterator<Byte> for NumberPool {
    fn from_iter<T: IntoIterator<Item = Byte>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
impl ::core::iter::FromIterator<u8> for NumberPool {
    fn from_iter<T: IntoIterator<Item = u8>>(iter: T) -> Self {
        Self::new_builder()
            .extend(iter.into_iter().map(Into::into))
            .build()
    }
}
#[derive(Clone)]
pub struct NumberRange(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for NumberRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for NumberRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for NumberRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "min", self.min())?;
        write!(f, ", {}: {}", "max", self.max())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for NumberRange {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        NumberRange::new_unchecked(v)
    }
}
impl NumberRange {
    const DEFAULT_VALUE: [u8; 14] = [14, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn min(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn max(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte::new_unchecked(self.0.slice(start..end))
        } else {
            Byte::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> NumberRangeReader<'r> {
        NumberRangeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for NumberRange {
    type Builder = NumberRangeBuilder;
    const NAME: &'static str = "NumberRange";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        NumberRange(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberRangeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberRangeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().min(self.min()).max(self.max())
    }
}
#[derive(Clone, Copy)]
pub struct NumberRangeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for NumberRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for NumberRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for NumberRangeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "min", self.min())?;
        write!(f, ", {}: {}", "max", self.max())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> NumberRangeReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn min(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn max(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            ByteReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ByteReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for NumberRangeReader<'r> {
    type Entity = NumberRange;
    const NAME: &'static str = "NumberRangeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NumberRangeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ByteReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct NumberRangeBuilder {
    pub(crate) min: Byte,
    pub(crate) max: Byte,
}
impl NumberRangeBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn min(mut self, v: Byte) -> Self {
        self.min = v;
        self
    }
    pub fn max(mut self, v: Byte) -> Self {
        self.max = v;
        self
    }
}
impl molecule::prelude::Builder for NumberRangeBuilder {
    type Entity = NumberRange;
    const NAME: &'static str = "NumberRangeBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.min.as_slice().len()
            + self.max.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.min.as_slice().len();
        offsets.push(total_size);
        total_size += self.max.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.min.as_slice())?;
        writer.write_all(self.max.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        NumberRange::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Instruction(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Instruction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Instruction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Instruction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for Instruction {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Instruction::new_unchecked(v)
    }
}
impl Instruction {
    const DEFAULT_VALUE: [u8; 18] = [0, 0, 0, 0, 14, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0];
    pub const ITEMS_COUNT: usize = 3;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> InstructionUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => NumberRange::new_unchecked(inner).into(),
            1 => NumberPool::new_unchecked(inner).into(),
            2 => UTF8Bytes::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> InstructionReader<'r> {
        InstructionReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Instruction {
    type Builder = InstructionBuilder;
    const NAME: &'static str = "Instruction";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Instruction(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        InstructionReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        InstructionReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct InstructionReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for InstructionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for InstructionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for InstructionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> InstructionReader<'r> {
    pub const ITEMS_COUNT: usize = 3;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> InstructionUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => NumberRangeReader::new_unchecked(inner).into(),
            1 => NumberPoolReader::new_unchecked(inner).into(),
            2 => UTF8BytesReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for InstructionReader<'r> {
    type Entity = Instruction;
    const NAME: &'static str = "InstructionReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        InstructionReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => NumberRangeReader::verify(inner_slice, compatible),
            1 => NumberPoolReader::verify(inner_slice, compatible),
            2 => UTF8BytesReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct InstructionBuilder(pub(crate) InstructionUnion);
impl InstructionBuilder {
    pub const ITEMS_COUNT: usize = 3;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<InstructionUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for InstructionBuilder {
    type Entity = Instruction;
    const NAME: &'static str = "InstructionBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Instruction::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum InstructionUnion {
    NumberRange(NumberRange),
    NumberPool(NumberPool),
    UTF8Bytes(UTF8Bytes),
}
#[derive(Debug, Clone, Copy)]
pub enum InstructionUnionReader<'r> {
    NumberRange(NumberRangeReader<'r>),
    NumberPool(NumberPoolReader<'r>),
    UTF8Bytes(UTF8BytesReader<'r>),
}
impl ::core::default::Default for InstructionUnion {
    fn default() -> Self {
        InstructionUnion::NumberRange(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for InstructionUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            InstructionUnion::NumberRange(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberRange::NAME, item)
            }
            InstructionUnion::NumberPool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberPool::NAME, item)
            }
            InstructionUnion::UTF8Bytes(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, UTF8Bytes::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for InstructionUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            InstructionUnionReader::NumberRange(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberRange::NAME, item)
            }
            InstructionUnionReader::NumberPool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberPool::NAME, item)
            }
            InstructionUnionReader::UTF8Bytes(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, UTF8Bytes::NAME, item)
            }
        }
    }
}
impl InstructionUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            InstructionUnion::NumberRange(ref item) => write!(f, "{}", item),
            InstructionUnion::NumberPool(ref item) => write!(f, "{}", item),
            InstructionUnion::UTF8Bytes(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> InstructionUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            InstructionUnionReader::NumberRange(ref item) => write!(f, "{}", item),
            InstructionUnionReader::NumberPool(ref item) => write!(f, "{}", item),
            InstructionUnionReader::UTF8Bytes(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<NumberRange> for InstructionUnion {
    fn from(item: NumberRange) -> Self {
        InstructionUnion::NumberRange(item)
    }
}
impl ::core::convert::From<NumberPool> for InstructionUnion {
    fn from(item: NumberPool) -> Self {
        InstructionUnion::NumberPool(item)
    }
}
impl ::core::convert::From<UTF8Bytes> for InstructionUnion {
    fn from(item: UTF8Bytes) -> Self {
        InstructionUnion::UTF8Bytes(item)
    }
}
impl<'r> ::core::convert::From<NumberRangeReader<'r>> for InstructionUnionReader<'r> {
    fn from(item: NumberRangeReader<'r>) -> Self {
        InstructionUnionReader::NumberRange(item)
    }
}
impl<'r> ::core::convert::From<NumberPoolReader<'r>> for InstructionUnionReader<'r> {
    fn from(item: NumberPoolReader<'r>) -> Self {
        InstructionUnionReader::NumberPool(item)
    }
}
impl<'r> ::core::convert::From<UTF8BytesReader<'r>> for InstructionUnionReader<'r> {
    fn from(item: UTF8BytesReader<'r>) -> Self {
        InstructionUnionReader::UTF8Bytes(item)
    }
}
impl InstructionUnion {
    pub const NAME: &'static str = "InstructionUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            InstructionUnion::NumberRange(item) => item.as_bytes(),
            InstructionUnion::NumberPool(item) => item.as_bytes(),
            InstructionUnion::UTF8Bytes(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            InstructionUnion::NumberRange(item) => item.as_slice(),
            InstructionUnion::NumberPool(item) => item.as_slice(),
            InstructionUnion::UTF8Bytes(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            InstructionUnion::NumberRange(_) => 0,
            InstructionUnion::NumberPool(_) => 1,
            InstructionUnion::UTF8Bytes(_) => 2,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            InstructionUnion::NumberRange(_) => "NumberRange",
            InstructionUnion::NumberPool(_) => "NumberPool",
            InstructionUnion::UTF8Bytes(_) => "UTF8Bytes",
        }
    }
    pub fn as_reader<'r>(&'r self) -> InstructionUnionReader<'r> {
        match self {
            InstructionUnion::NumberRange(item) => item.as_reader().into(),
            InstructionUnion::NumberPool(item) => item.as_reader().into(),
            InstructionUnion::UTF8Bytes(item) => item.as_reader().into(),
        }
    }
}
impl<'r> InstructionUnionReader<'r> {
    pub const NAME: &'r str = "InstructionUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            InstructionUnionReader::NumberRange(item) => item.as_slice(),
            InstructionUnionReader::NumberPool(item) => item.as_slice(),
            InstructionUnionReader::UTF8Bytes(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            InstructionUnionReader::NumberRange(_) => 0,
            InstructionUnionReader::NumberPool(_) => 1,
            InstructionUnionReader::UTF8Bytes(_) => 2,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            InstructionUnionReader::NumberRange(_) => "NumberRange",
            InstructionUnionReader::NumberPool(_) => "NumberPool",
            InstructionUnionReader::UTF8Bytes(_) => "UTF8Bytes",
        }
    }
}
impl From<NumberRange> for Instruction {
    fn from(value: NumberRange) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<NumberPool> for Instruction {
    fn from(value: NumberPool) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<UTF8Bytes> for Instruction {
    fn from(value: UTF8Bytes) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct InstructionVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for InstructionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for InstructionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for InstructionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for InstructionVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        InstructionVec::new_unchecked(v)
    }
}
impl InstructionVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Instruction> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Instruction {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Instruction::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Instruction::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> InstructionVecReader<'r> {
        InstructionVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for InstructionVec {
    type Builder = InstructionVecBuilder;
    const NAME: &'static str = "InstructionVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        InstructionVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        InstructionVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        InstructionVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct InstructionVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for InstructionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for InstructionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for InstructionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> InstructionVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<InstructionReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> InstructionReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            InstructionReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            InstructionReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for InstructionVecReader<'r> {
    type Entity = InstructionVec;
    const NAME: &'static str = "InstructionVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        InstructionVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            InstructionReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct InstructionVecBuilder(pub(crate) Vec<Instruction>);
impl InstructionVecBuilder {
    pub fn set(mut self, v: Vec<Instruction>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Instruction) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Instruction>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Instruction) -> Option<Instruction> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for InstructionVecBuilder {
    type Entity = InstructionVec;
    const NAME: &'static str = "InstructionVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        InstructionVec::new_unchecked(inner.into())
    }
}
pub struct InstructionVecIterator(InstructionVec, usize, usize);
impl ::core::iter::Iterator for InstructionVecIterator {
    type Item = Instruction;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for InstructionVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for InstructionVec {
    type Item = Instruction;
    type IntoIter = InstructionVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        InstructionVecIterator(self, 0, len)
    }
}
impl<'r> InstructionVecReader<'r> {
    pub fn iter<'t>(&'t self) -> InstructionVecReaderIterator<'t, 'r> {
        InstructionVecReaderIterator(&self, 0, self.len())
    }
}
pub struct InstructionVecReaderIterator<'t, 'r>(&'t InstructionVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for InstructionVecReaderIterator<'t, 'r> {
    type Item = InstructionReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for InstructionVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<Instruction> for InstructionVec {
    fn from_iter<T: IntoIterator<Item = Instruction>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
#[derive(Clone)]
pub struct TemplatePool(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TemplatePool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TemplatePool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TemplatePool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for TemplatePool {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TemplatePool::new_unchecked(v)
    }
}
impl TemplatePool {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<InstructionVec> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> InstructionVec {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            InstructionVec::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            InstructionVec::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TemplatePoolReader<'r> {
        TemplatePoolReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TemplatePool {
    type Builder = TemplatePoolBuilder;
    const NAME: &'static str = "TemplatePool";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TemplatePool(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TemplatePoolReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TemplatePoolReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct TemplatePoolReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TemplatePoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TemplatePoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TemplatePoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> TemplatePoolReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<InstructionVecReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> InstructionVecReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            InstructionVecReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            InstructionVecReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TemplatePoolReader<'r> {
    type Entity = TemplatePool;
    const NAME: &'static str = "TemplatePoolReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TemplatePoolReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            InstructionVecReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TemplatePoolBuilder(pub(crate) Vec<InstructionVec>);
impl TemplatePoolBuilder {
    pub fn set(mut self, v: Vec<InstructionVec>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: InstructionVec) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = InstructionVec>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: InstructionVec) -> Option<InstructionVec> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for TemplatePoolBuilder {
    type Entity = TemplatePool;
    const NAME: &'static str = "TemplatePoolBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TemplatePool::new_unchecked(inner.into())
    }
}
pub struct TemplatePoolIterator(TemplatePool, usize, usize);
impl ::core::iter::Iterator for TemplatePoolIterator {
    type Item = InstructionVec;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for TemplatePoolIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for TemplatePool {
    type Item = InstructionVec;
    type IntoIter = TemplatePoolIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        TemplatePoolIterator(self, 0, len)
    }
}
impl<'r> TemplatePoolReader<'r> {
    pub fn iter<'t>(&'t self) -> TemplatePoolReaderIterator<'t, 'r> {
        TemplatePoolReaderIterator(&self, 0, self.len())
    }
}
pub struct TemplatePoolReaderIterator<'t, 'r>(&'t TemplatePoolReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for TemplatePoolReaderIterator<'t, 'r> {
    type Item = InstructionVecReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for TemplatePoolReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<InstructionVec> for TemplatePool {
    fn from_iter<T: IntoIterator<Item = InstructionVec>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
#[derive(Clone)]
pub struct Pool(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Pool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Pool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Pool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for Pool {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Pool::new_unchecked(v)
    }
}
impl Pool {
    const DEFAULT_VALUE: [u8; 8] = [0, 0, 0, 0, 4, 0, 0, 0];
    pub const ITEMS_COUNT: usize = 4;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> PoolUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => TraitPool::new_unchecked(inner).into(),
            1 => NumberPool::new_unchecked(inner).into(),
            2 => NumberRange::new_unchecked(inner).into(),
            3 => TemplatePool::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> PoolReader<'r> {
        PoolReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Pool {
    type Builder = PoolBuilder;
    const NAME: &'static str = "Pool";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Pool(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PoolReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PoolReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct PoolReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> PoolReader<'r> {
    pub const ITEMS_COUNT: usize = 4;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> PoolUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => TraitPoolReader::new_unchecked(inner).into(),
            1 => NumberPoolReader::new_unchecked(inner).into(),
            2 => NumberRangeReader::new_unchecked(inner).into(),
            3 => TemplatePoolReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PoolReader<'r> {
    type Entity = Pool;
    const NAME: &'static str = "PoolReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PoolReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => TraitPoolReader::verify(inner_slice, compatible),
            1 => NumberPoolReader::verify(inner_slice, compatible),
            2 => NumberRangeReader::verify(inner_slice, compatible),
            3 => TemplatePoolReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct PoolBuilder(pub(crate) PoolUnion);
impl PoolBuilder {
    pub const ITEMS_COUNT: usize = 4;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<PoolUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for PoolBuilder {
    type Entity = Pool;
    const NAME: &'static str = "PoolBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Pool::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum PoolUnion {
    TraitPool(TraitPool),
    NumberPool(NumberPool),
    NumberRange(NumberRange),
    TemplatePool(TemplatePool),
}
#[derive(Debug, Clone, Copy)]
pub enum PoolUnionReader<'r> {
    TraitPool(TraitPoolReader<'r>),
    NumberPool(NumberPoolReader<'r>),
    NumberRange(NumberRangeReader<'r>),
    TemplatePool(TemplatePoolReader<'r>),
}
impl ::core::default::Default for PoolUnion {
    fn default() -> Self {
        PoolUnion::TraitPool(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for PoolUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PoolUnion::TraitPool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TraitPool::NAME, item)
            }
            PoolUnion::NumberPool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberPool::NAME, item)
            }
            PoolUnion::NumberRange(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberRange::NAME, item)
            }
            PoolUnion::TemplatePool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TemplatePool::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for PoolUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PoolUnionReader::TraitPool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TraitPool::NAME, item)
            }
            PoolUnionReader::NumberPool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberPool::NAME, item)
            }
            PoolUnionReader::NumberRange(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, NumberRange::NAME, item)
            }
            PoolUnionReader::TemplatePool(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, TemplatePool::NAME, item)
            }
        }
    }
}
impl PoolUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PoolUnion::TraitPool(ref item) => write!(f, "{}", item),
            PoolUnion::NumberPool(ref item) => write!(f, "{}", item),
            PoolUnion::NumberRange(ref item) => write!(f, "{}", item),
            PoolUnion::TemplatePool(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> PoolUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PoolUnionReader::TraitPool(ref item) => write!(f, "{}", item),
            PoolUnionReader::NumberPool(ref item) => write!(f, "{}", item),
            PoolUnionReader::NumberRange(ref item) => write!(f, "{}", item),
            PoolUnionReader::TemplatePool(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<TraitPool> for PoolUnion {
    fn from(item: TraitPool) -> Self {
        PoolUnion::TraitPool(item)
    }
}
impl ::core::convert::From<NumberPool> for PoolUnion {
    fn from(item: NumberPool) -> Self {
        PoolUnion::NumberPool(item)
    }
}
impl ::core::convert::From<NumberRange> for PoolUnion {
    fn from(item: NumberRange) -> Self {
        PoolUnion::NumberRange(item)
    }
}
impl ::core::convert::From<TemplatePool> for PoolUnion {
    fn from(item: TemplatePool) -> Self {
        PoolUnion::TemplatePool(item)
    }
}
impl<'r> ::core::convert::From<TraitPoolReader<'r>> for PoolUnionReader<'r> {
    fn from(item: TraitPoolReader<'r>) -> Self {
        PoolUnionReader::TraitPool(item)
    }
}
impl<'r> ::core::convert::From<NumberPoolReader<'r>> for PoolUnionReader<'r> {
    fn from(item: NumberPoolReader<'r>) -> Self {
        PoolUnionReader::NumberPool(item)
    }
}
impl<'r> ::core::convert::From<NumberRangeReader<'r>> for PoolUnionReader<'r> {
    fn from(item: NumberRangeReader<'r>) -> Self {
        PoolUnionReader::NumberRange(item)
    }
}
impl<'r> ::core::convert::From<TemplatePoolReader<'r>> for PoolUnionReader<'r> {
    fn from(item: TemplatePoolReader<'r>) -> Self {
        PoolUnionReader::TemplatePool(item)
    }
}
impl PoolUnion {
    pub const NAME: &'static str = "PoolUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            PoolUnion::TraitPool(item) => item.as_bytes(),
            PoolUnion::NumberPool(item) => item.as_bytes(),
            PoolUnion::NumberRange(item) => item.as_bytes(),
            PoolUnion::TemplatePool(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            PoolUnion::TraitPool(item) => item.as_slice(),
            PoolUnion::NumberPool(item) => item.as_slice(),
            PoolUnion::NumberRange(item) => item.as_slice(),
            PoolUnion::TemplatePool(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            PoolUnion::TraitPool(_) => 0,
            PoolUnion::NumberPool(_) => 1,
            PoolUnion::NumberRange(_) => 2,
            PoolUnion::TemplatePool(_) => 3,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            PoolUnion::TraitPool(_) => "TraitPool",
            PoolUnion::NumberPool(_) => "NumberPool",
            PoolUnion::NumberRange(_) => "NumberRange",
            PoolUnion::TemplatePool(_) => "TemplatePool",
        }
    }
    pub fn as_reader<'r>(&'r self) -> PoolUnionReader<'r> {
        match self {
            PoolUnion::TraitPool(item) => item.as_reader().into(),
            PoolUnion::NumberPool(item) => item.as_reader().into(),
            PoolUnion::NumberRange(item) => item.as_reader().into(),
            PoolUnion::TemplatePool(item) => item.as_reader().into(),
        }
    }
}
impl<'r> PoolUnionReader<'r> {
    pub const NAME: &'r str = "PoolUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            PoolUnionReader::TraitPool(item) => item.as_slice(),
            PoolUnionReader::NumberPool(item) => item.as_slice(),
            PoolUnionReader::NumberRange(item) => item.as_slice(),
            PoolUnionReader::TemplatePool(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            PoolUnionReader::TraitPool(_) => 0,
            PoolUnionReader::NumberPool(_) => 1,
            PoolUnionReader::NumberRange(_) => 2,
            PoolUnionReader::TemplatePool(_) => 3,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            PoolUnionReader::TraitPool(_) => "TraitPool",
            PoolUnionReader::NumberPool(_) => "NumberPool",
            PoolUnionReader::NumberRange(_) => "NumberRange",
            PoolUnionReader::TemplatePool(_) => "TemplatePool",
        }
    }
}
impl From<TraitPool> for Pool {
    fn from(value: TraitPool) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<NumberPool> for Pool {
    fn from(value: NumberPool) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<NumberRange> for Pool {
    fn from(value: NumberRange) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<TemplatePool> for Pool {
    fn from(value: TemplatePool) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct Segment(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Segment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Segment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Segment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "segment_bytes", self.segment_bytes())?;
        write!(f, ", {}: {}", "pool", self.pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Segment {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Segment::new_unchecked(v)
    }
}
impl Segment {
    const DEFAULT_VALUE: [u8; 21] = [
        21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn segment_bytes(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn pool(&self) -> Pool {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Pool::new_unchecked(self.0.slice(start..end))
        } else {
            Pool::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SegmentReader<'r> {
        SegmentReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Segment {
    type Builder = SegmentBuilder;
    const NAME: &'static str = "Segment";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Segment(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SegmentReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SegmentReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .segment_bytes(self.segment_bytes())
            .pool(self.pool())
    }
}
#[derive(Clone, Copy)]
pub struct SegmentReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SegmentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SegmentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SegmentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "segment_bytes", self.segment_bytes())?;
        write!(f, ", {}: {}", "pool", self.pool())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SegmentReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn segment_bytes(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pool(&self) -> PoolReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            PoolReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            PoolReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SegmentReader<'r> {
    type Entity = Segment;
    const NAME: &'static str = "SegmentReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SegmentReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        PoolReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct SegmentBuilder {
    pub(crate) segment_bytes: Byte,
    pub(crate) pool: Pool,
}
impl SegmentBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn segment_bytes(mut self, v: Byte) -> Self {
        self.segment_bytes = v;
        self
    }
    pub fn pool(mut self, v: Pool) -> Self {
        self.pool = v;
        self
    }
}
impl molecule::prelude::Builder for SegmentBuilder {
    type Entity = Segment;
    const NAME: &'static str = "SegmentBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.segment_bytes.as_slice().len()
            + self.pool.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.segment_bytes.as_slice().len();
        offsets.push(total_size);
        total_size += self.pool.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.segment_bytes.as_slice())?;
        writer.write_all(self.pool.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Segment::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SegmentVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SegmentVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SegmentVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SegmentVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for SegmentVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SegmentVec::new_unchecked(v)
    }
}
impl SegmentVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Segment> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Segment {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Segment::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Segment::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SegmentVecReader<'r> {
        SegmentVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SegmentVec {
    type Builder = SegmentVecBuilder;
    const NAME: &'static str = "SegmentVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SegmentVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SegmentVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SegmentVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct SegmentVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SegmentVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SegmentVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SegmentVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> SegmentVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<SegmentReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> SegmentReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            SegmentReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            SegmentReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SegmentVecReader<'r> {
    type Entity = SegmentVec;
    const NAME: &'static str = "SegmentVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SegmentVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            SegmentReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct SegmentVecBuilder(pub(crate) Vec<Segment>);
impl SegmentVecBuilder {
    pub fn set(mut self, v: Vec<Segment>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Segment) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Segment>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Segment) -> Option<Segment> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for SegmentVecBuilder {
    type Entity = SegmentVec;
    const NAME: &'static str = "SegmentVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SegmentVec::new_unchecked(inner.into())
    }
}
pub struct SegmentVecIterator(SegmentVec, usize, usize);
impl ::core::iter::Iterator for SegmentVecIterator {
    type Item = Segment;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for SegmentVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for SegmentVec {
    type Item = Segment;
    type IntoIter = SegmentVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        SegmentVecIterator(self, 0, len)
    }
}
impl<'r> SegmentVecReader<'r> {
    pub fn iter<'t>(&'t self) -> SegmentVecReaderIterator<'t, 'r> {
        SegmentVecReaderIterator(&self, 0, self.len())
    }
}
pub struct SegmentVecReaderIterator<'t, 'r>(&'t SegmentVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for SegmentVecReaderIterator<'t, 'r> {
    type Item = SegmentReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for SegmentVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<Segment> for SegmentVec {
    fn from_iter<T: IntoIterator<Item = Segment>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
#[derive(Clone)]
pub struct VariableSegment(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for VariableSegment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for VariableSegment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for VariableSegment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "count", self.count())?;
        write!(f, ", {}: {}", "segments", self.segments())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for VariableSegment {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        VariableSegment::new_unchecked(v)
    }
}
impl VariableSegment {
    const DEFAULT_VALUE: [u8; 37] = [
        37, 0, 0, 0, 12, 0, 0, 0, 33, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0,
        0, 4, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn count(&self) -> Segment {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Segment::new_unchecked(self.0.slice(start..end))
    }
    pub fn segments(&self) -> SegmentVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            SegmentVec::new_unchecked(self.0.slice(start..end))
        } else {
            SegmentVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> VariableSegmentReader<'r> {
        VariableSegmentReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for VariableSegment {
    type Builder = VariableSegmentBuilder;
    const NAME: &'static str = "VariableSegment";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        VariableSegment(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        VariableSegmentReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        VariableSegmentReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .count(self.count())
            .segments(self.segments())
    }
}
#[derive(Clone, Copy)]
pub struct VariableSegmentReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for VariableSegmentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for VariableSegmentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for VariableSegmentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "count", self.count())?;
        write!(f, ", {}: {}", "segments", self.segments())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> VariableSegmentReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn count(&self) -> SegmentReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        SegmentReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn segments(&self) -> SegmentVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            SegmentVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            SegmentVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for VariableSegmentReader<'r> {
    type Entity = VariableSegment;
    const NAME: &'static str = "VariableSegmentReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        VariableSegmentReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        SegmentReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        SegmentVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct VariableSegmentBuilder {
    pub(crate) count: Segment,
    pub(crate) segments: SegmentVec,
}
impl VariableSegmentBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn count(mut self, v: Segment) -> Self {
        self.count = v;
        self
    }
    pub fn segments(mut self, v: SegmentVec) -> Self {
        self.segments = v;
        self
    }
}
impl molecule::prelude::Builder for VariableSegmentBuilder {
    type Entity = VariableSegment;
    const NAME: &'static str = "VariableSegmentBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.count.as_slice().len()
            + self.segments.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.count.as_slice().len();
        offsets.push(total_size);
        total_size += self.segments.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.count.as_slice())?;
        writer.write_all(self.segments.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        VariableSegment::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct VariableSegmentVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for VariableSegmentVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for VariableSegmentVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for VariableSegmentVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for VariableSegmentVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        VariableSegmentVec::new_unchecked(v)
    }
}
impl VariableSegmentVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<VariableSegment> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> VariableSegment {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            VariableSegment::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            VariableSegment::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> VariableSegmentVecReader<'r> {
        VariableSegmentVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for VariableSegmentVec {
    type Builder = VariableSegmentVecBuilder;
    const NAME: &'static str = "VariableSegmentVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        VariableSegmentVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        VariableSegmentVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        VariableSegmentVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct VariableSegmentVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for VariableSegmentVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for VariableSegmentVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for VariableSegmentVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> VariableSegmentVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<VariableSegmentReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> VariableSegmentReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            VariableSegmentReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            VariableSegmentReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for VariableSegmentVecReader<'r> {
    type Entity = VariableSegmentVec;
    const NAME: &'static str = "VariableSegmentVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        VariableSegmentVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            VariableSegmentReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct VariableSegmentVecBuilder(pub(crate) Vec<VariableSegment>);
impl VariableSegmentVecBuilder {
    pub fn set(mut self, v: Vec<VariableSegment>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: VariableSegment) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = VariableSegment>>(
        mut self,
        iter: T,
    ) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: VariableSegment) -> Option<VariableSegment> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for VariableSegmentVecBuilder {
    type Entity = VariableSegmentVec;
    const NAME: &'static str = "VariableSegmentVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        VariableSegmentVec::new_unchecked(inner.into())
    }
}
pub struct VariableSegmentVecIterator(VariableSegmentVec, usize, usize);
impl ::core::iter::Iterator for VariableSegmentVecIterator {
    type Item = VariableSegment;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for VariableSegmentVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for VariableSegmentVec {
    type Item = VariableSegment;
    type IntoIter = VariableSegmentVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        VariableSegmentVecIterator(self, 0, len)
    }
}
impl<'r> VariableSegmentVecReader<'r> {
    pub fn iter<'t>(&'t self) -> VariableSegmentVecReaderIterator<'t, 'r> {
        VariableSegmentVecReaderIterator(&self, 0, self.len())
    }
}
pub struct VariableSegmentVecReaderIterator<'t, 'r>(&'t VariableSegmentVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for VariableSegmentVecReaderIterator<'t, 'r> {
    type Item = VariableSegmentReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for VariableSegmentVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<VariableSegment> for VariableSegmentVec {
    fn from_iter<T: IntoIterator<Item = VariableSegment>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
#[derive(Clone)]
pub struct Pattern(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Pattern {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Pattern {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Pattern {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for Pattern {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Pattern::new_unchecked(v)
    }
}
impl Pattern {
    const DEFAULT_VALUE: [u8; 25] = [
        0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 4;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> PatternUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => Segment::new_unchecked(inner).into(),
            1 => SegmentVec::new_unchecked(inner).into(),
            2 => VariableSegment::new_unchecked(inner).into(),
            3 => VariableSegmentVec::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> PatternReader<'r> {
        PatternReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Pattern {
    type Builder = PatternBuilder;
    const NAME: &'static str = "Pattern";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Pattern(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PatternReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PatternReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct PatternReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PatternReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PatternReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PatternReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> PatternReader<'r> {
    pub const ITEMS_COUNT: usize = 4;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> PatternUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => SegmentReader::new_unchecked(inner).into(),
            1 => SegmentVecReader::new_unchecked(inner).into(),
            2 => VariableSegmentReader::new_unchecked(inner).into(),
            3 => VariableSegmentVecReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PatternReader<'r> {
    type Entity = Pattern;
    const NAME: &'static str = "PatternReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PatternReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => SegmentReader::verify(inner_slice, compatible),
            1 => SegmentVecReader::verify(inner_slice, compatible),
            2 => VariableSegmentReader::verify(inner_slice, compatible),
            3 => VariableSegmentVecReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct PatternBuilder(pub(crate) PatternUnion);
impl PatternBuilder {
    pub const ITEMS_COUNT: usize = 4;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<PatternUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for PatternBuilder {
    type Entity = Pattern;
    const NAME: &'static str = "PatternBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Pattern::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum PatternUnion {
    Segment(Segment),
    SegmentVec(SegmentVec),
    VariableSegment(VariableSegment),
    VariableSegmentVec(VariableSegmentVec),
}
#[derive(Debug, Clone, Copy)]
pub enum PatternUnionReader<'r> {
    Segment(SegmentReader<'r>),
    SegmentVec(SegmentVecReader<'r>),
    VariableSegment(VariableSegmentReader<'r>),
    VariableSegmentVec(VariableSegmentVecReader<'r>),
}
impl ::core::default::Default for PatternUnion {
    fn default() -> Self {
        PatternUnion::Segment(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for PatternUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PatternUnion::Segment(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Segment::NAME, item)
            }
            PatternUnion::SegmentVec(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SegmentVec::NAME, item)
            }
            PatternUnion::VariableSegment(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, VariableSegment::NAME, item)
            }
            PatternUnion::VariableSegmentVec(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, VariableSegmentVec::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for PatternUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PatternUnionReader::Segment(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Segment::NAME, item)
            }
            PatternUnionReader::SegmentVec(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SegmentVec::NAME, item)
            }
            PatternUnionReader::VariableSegment(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, VariableSegment::NAME, item)
            }
            PatternUnionReader::VariableSegmentVec(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, VariableSegmentVec::NAME, item)
            }
        }
    }
}
impl PatternUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PatternUnion::Segment(ref item) => write!(f, "{}", item),
            PatternUnion::SegmentVec(ref item) => write!(f, "{}", item),
            PatternUnion::VariableSegment(ref item) => write!(f, "{}", item),
            PatternUnion::VariableSegmentVec(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> PatternUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            PatternUnionReader::Segment(ref item) => write!(f, "{}", item),
            PatternUnionReader::SegmentVec(ref item) => write!(f, "{}", item),
            PatternUnionReader::VariableSegment(ref item) => write!(f, "{}", item),
            PatternUnionReader::VariableSegmentVec(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<Segment> for PatternUnion {
    fn from(item: Segment) -> Self {
        PatternUnion::Segment(item)
    }
}
impl ::core::convert::From<SegmentVec> for PatternUnion {
    fn from(item: SegmentVec) -> Self {
        PatternUnion::SegmentVec(item)
    }
}
impl ::core::convert::From<VariableSegment> for PatternUnion {
    fn from(item: VariableSegment) -> Self {
        PatternUnion::VariableSegment(item)
    }
}
impl ::core::convert::From<VariableSegmentVec> for PatternUnion {
    fn from(item: VariableSegmentVec) -> Self {
        PatternUnion::VariableSegmentVec(item)
    }
}
impl<'r> ::core::convert::From<SegmentReader<'r>> for PatternUnionReader<'r> {
    fn from(item: SegmentReader<'r>) -> Self {
        PatternUnionReader::Segment(item)
    }
}
impl<'r> ::core::convert::From<SegmentVecReader<'r>> for PatternUnionReader<'r> {
    fn from(item: SegmentVecReader<'r>) -> Self {
        PatternUnionReader::SegmentVec(item)
    }
}
impl<'r> ::core::convert::From<VariableSegmentReader<'r>> for PatternUnionReader<'r> {
    fn from(item: VariableSegmentReader<'r>) -> Self {
        PatternUnionReader::VariableSegment(item)
    }
}
impl<'r> ::core::convert::From<VariableSegmentVecReader<'r>> for PatternUnionReader<'r> {
    fn from(item: VariableSegmentVecReader<'r>) -> Self {
        PatternUnionReader::VariableSegmentVec(item)
    }
}
impl PatternUnion {
    pub const NAME: &'static str = "PatternUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            PatternUnion::Segment(item) => item.as_bytes(),
            PatternUnion::SegmentVec(item) => item.as_bytes(),
            PatternUnion::VariableSegment(item) => item.as_bytes(),
            PatternUnion::VariableSegmentVec(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            PatternUnion::Segment(item) => item.as_slice(),
            PatternUnion::SegmentVec(item) => item.as_slice(),
            PatternUnion::VariableSegment(item) => item.as_slice(),
            PatternUnion::VariableSegmentVec(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            PatternUnion::Segment(_) => 0,
            PatternUnion::SegmentVec(_) => 1,
            PatternUnion::VariableSegment(_) => 2,
            PatternUnion::VariableSegmentVec(_) => 3,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            PatternUnion::Segment(_) => "Segment",
            PatternUnion::SegmentVec(_) => "SegmentVec",
            PatternUnion::VariableSegment(_) => "VariableSegment",
            PatternUnion::VariableSegmentVec(_) => "VariableSegmentVec",
        }
    }
    pub fn as_reader<'r>(&'r self) -> PatternUnionReader<'r> {
        match self {
            PatternUnion::Segment(item) => item.as_reader().into(),
            PatternUnion::SegmentVec(item) => item.as_reader().into(),
            PatternUnion::VariableSegment(item) => item.as_reader().into(),
            PatternUnion::VariableSegmentVec(item) => item.as_reader().into(),
        }
    }
}
impl<'r> PatternUnionReader<'r> {
    pub const NAME: &'r str = "PatternUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            PatternUnionReader::Segment(item) => item.as_slice(),
            PatternUnionReader::SegmentVec(item) => item.as_slice(),
            PatternUnionReader::VariableSegment(item) => item.as_slice(),
            PatternUnionReader::VariableSegmentVec(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            PatternUnionReader::Segment(_) => 0,
            PatternUnionReader::SegmentVec(_) => 1,
            PatternUnionReader::VariableSegment(_) => 2,
            PatternUnionReader::VariableSegmentVec(_) => 3,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            PatternUnionReader::Segment(_) => "Segment",
            PatternUnionReader::SegmentVec(_) => "SegmentVec",
            PatternUnionReader::VariableSegment(_) => "VariableSegment",
            PatternUnionReader::VariableSegmentVec(_) => "VariableSegmentVec",
        }
    }
}
impl From<Segment> for Pattern {
    fn from(value: Segment) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<SegmentVec> for Pattern {
    fn from(value: SegmentVec) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<VariableSegment> for Pattern {
    fn from(value: VariableSegment) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<VariableSegmentVec> for Pattern {
    fn from(value: VariableSegmentVec) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct Schema(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Schema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Schema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Schema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "occupied_bytes", self.occupied_bytes())?;
        write!(f, ", {}: {}", "pattern", self.pattern())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Schema {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Schema::new_unchecked(v)
    }
}
impl Schema {
    const DEFAULT_VALUE: [u8; 38] = [
        38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0,
        0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn occupied_bytes(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn pattern(&self) -> Pattern {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Pattern::new_unchecked(self.0.slice(start..end))
        } else {
            Pattern::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SchemaReader<'r> {
        SchemaReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Schema {
    type Builder = SchemaBuilder;
    const NAME: &'static str = "Schema";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Schema(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SchemaReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SchemaReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .occupied_bytes(self.occupied_bytes())
            .pattern(self.pattern())
    }
}
#[derive(Clone, Copy)]
pub struct SchemaReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "occupied_bytes", self.occupied_bytes())?;
        write!(f, ", {}: {}", "pattern", self.pattern())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SchemaReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn occupied_bytes(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pattern(&self) -> PatternReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            PatternReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            PatternReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SchemaReader<'r> {
    type Entity = Schema;
    const NAME: &'static str = "SchemaReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SchemaReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        PatternReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct SchemaBuilder {
    pub(crate) occupied_bytes: Byte,
    pub(crate) pattern: Pattern,
}
impl SchemaBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn occupied_bytes(mut self, v: Byte) -> Self {
        self.occupied_bytes = v;
        self
    }
    pub fn pattern(mut self, v: Pattern) -> Self {
        self.pattern = v;
        self
    }
}
impl molecule::prelude::Builder for SchemaBuilder {
    type Entity = Schema;
    const NAME: &'static str = "SchemaBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.occupied_bytes.as_slice().len()
            + self.pattern.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.occupied_bytes.as_slice().len();
        offsets.push(total_size);
        total_size += self.pattern.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.occupied_bytes.as_slice())?;
        writer.write_all(self.pattern.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Schema::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct CharacterSchema(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CharacterSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CharacterSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CharacterSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "adjective", self.adjective())?;
        write!(f, ", {}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "profession", self.profession())?;
        write!(f, ", {}: {}", "hp", self.hp())?;
        write!(f, ", {}: {}", "power", self.power())?;
        write!(f, ", {}: {}", "attack", self.attack())?;
        write!(f, ", {}: {}", "defense", self.defense())?;
        write!(f, ", {}: {}", "gold", self.gold())?;
        write!(f, ", {}: {}", "card", self.card())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for CharacterSchema {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        CharacterSchema::new_unchecked(v)
    }
}
impl CharacterSchema {
    const DEFAULT_VALUE: [u8; 382] = [
        126, 1, 0, 0, 40, 0, 0, 0, 78, 0, 0, 0, 116, 0, 0, 0, 154, 0, 0, 0, 192, 0, 0, 0, 230, 0,
        0, 0, 12, 1, 0, 0, 50, 1, 0, 0, 88, 1, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0,
        0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12,
        0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0,
        4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0,
        13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0,
        0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0,
        0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,
        0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13,
        0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0,
        21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0,
        13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0,
        0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0,
        0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 9;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn adjective(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn name(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn profession(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn hp(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn power(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn attack(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn defense(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn gold(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn card(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[40..]) as usize;
            Schema::new_unchecked(self.0.slice(start..end))
        } else {
            Schema::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CharacterSchemaReader<'r> {
        CharacterSchemaReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CharacterSchema {
    type Builder = CharacterSchemaBuilder;
    const NAME: &'static str = "CharacterSchema";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CharacterSchema(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CharacterSchemaReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CharacterSchemaReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .adjective(self.adjective())
            .name(self.name())
            .profession(self.profession())
            .hp(self.hp())
            .power(self.power())
            .attack(self.attack())
            .defense(self.defense())
            .gold(self.gold())
            .card(self.card())
    }
}
#[derive(Clone, Copy)]
pub struct CharacterSchemaReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CharacterSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CharacterSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CharacterSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "adjective", self.adjective())?;
        write!(f, ", {}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "profession", self.profession())?;
        write!(f, ", {}: {}", "hp", self.hp())?;
        write!(f, ", {}: {}", "power", self.power())?;
        write!(f, ", {}: {}", "attack", self.attack())?;
        write!(f, ", {}: {}", "defense", self.defense())?;
        write!(f, ", {}: {}", "gold", self.gold())?;
        write!(f, ", {}: {}", "card", self.card())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> CharacterSchemaReader<'r> {
    pub const FIELD_COUNT: usize = 9;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn adjective(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn name(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn profession(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn hp(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn power(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn attack(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn defense(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn gold(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn card(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[40..]) as usize;
            SchemaReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            SchemaReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CharacterSchemaReader<'r> {
    type Entity = CharacterSchema;
    const NAME: &'static str = "CharacterSchemaReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CharacterSchemaReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        SchemaReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        SchemaReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        SchemaReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        SchemaReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        SchemaReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        SchemaReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        SchemaReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        SchemaReader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        SchemaReader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct CharacterSchemaBuilder {
    pub(crate) adjective: Schema,
    pub(crate) name: Schema,
    pub(crate) profession: Schema,
    pub(crate) hp: Schema,
    pub(crate) power: Schema,
    pub(crate) attack: Schema,
    pub(crate) defense: Schema,
    pub(crate) gold: Schema,
    pub(crate) card: Schema,
}
impl CharacterSchemaBuilder {
    pub const FIELD_COUNT: usize = 9;
    pub fn adjective(mut self, v: Schema) -> Self {
        self.adjective = v;
        self
    }
    pub fn name(mut self, v: Schema) -> Self {
        self.name = v;
        self
    }
    pub fn profession(mut self, v: Schema) -> Self {
        self.profession = v;
        self
    }
    pub fn hp(mut self, v: Schema) -> Self {
        self.hp = v;
        self
    }
    pub fn power(mut self, v: Schema) -> Self {
        self.power = v;
        self
    }
    pub fn attack(mut self, v: Schema) -> Self {
        self.attack = v;
        self
    }
    pub fn defense(mut self, v: Schema) -> Self {
        self.defense = v;
        self
    }
    pub fn gold(mut self, v: Schema) -> Self {
        self.gold = v;
        self
    }
    pub fn card(mut self, v: Schema) -> Self {
        self.card = v;
        self
    }
}
impl molecule::prelude::Builder for CharacterSchemaBuilder {
    type Entity = CharacterSchema;
    const NAME: &'static str = "CharacterSchemaBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.adjective.as_slice().len()
            + self.name.as_slice().len()
            + self.profession.as_slice().len()
            + self.hp.as_slice().len()
            + self.power.as_slice().len()
            + self.attack.as_slice().len()
            + self.defense.as_slice().len()
            + self.gold.as_slice().len()
            + self.card.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.adjective.as_slice().len();
        offsets.push(total_size);
        total_size += self.name.as_slice().len();
        offsets.push(total_size);
        total_size += self.profession.as_slice().len();
        offsets.push(total_size);
        total_size += self.hp.as_slice().len();
        offsets.push(total_size);
        total_size += self.power.as_slice().len();
        offsets.push(total_size);
        total_size += self.attack.as_slice().len();
        offsets.push(total_size);
        total_size += self.defense.as_slice().len();
        offsets.push(total_size);
        total_size += self.gold.as_slice().len();
        offsets.push(total_size);
        total_size += self.card.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.adjective.as_slice())?;
        writer.write_all(self.name.as_slice())?;
        writer.write_all(self.profession.as_slice())?;
        writer.write_all(self.hp.as_slice())?;
        writer.write_all(self.power.as_slice())?;
        writer.write_all(self.attack.as_slice())?;
        writer.write_all(self.defense.as_slice())?;
        writer.write_all(self.gold.as_slice())?;
        writer.write_all(self.card.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CharacterSchema::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct LocationSchema(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for LocationSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for LocationSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for LocationSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "adjective", self.adjective())?;
        write!(f, ", {}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "belonging", self.belonging())?;
        write!(f, ", {}: {}", "coordinate", self.coordinate())?;
        write!(f, ", {}: {}", "area", self.area())?;
        write!(f, ", {}: {}", "color", self.color())?;
        write!(f, ", {}: {}", "commodity", self.commodity())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for LocationSchema {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        LocationSchema::new_unchecked(v)
    }
}
impl LocationSchema {
    const DEFAULT_VALUE: [u8; 298] = [
        42, 1, 0, 0, 32, 0, 0, 0, 70, 0, 0, 0, 108, 0, 0, 0, 146, 0, 0, 0, 184, 0, 0, 0, 222, 0, 0,
        0, 4, 1, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0,
        0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0,
        0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0,
        0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4,
        0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0,
        13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0,
        0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0,
        0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,
        0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13,
        0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn adjective(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn name(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn belonging(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn coordinate(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn area(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn color(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn commodity(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            Schema::new_unchecked(self.0.slice(start..end))
        } else {
            Schema::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> LocationSchemaReader<'r> {
        LocationSchemaReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for LocationSchema {
    type Builder = LocationSchemaBuilder;
    const NAME: &'static str = "LocationSchema";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        LocationSchema(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LocationSchemaReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LocationSchemaReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .adjective(self.adjective())
            .name(self.name())
            .belonging(self.belonging())
            .coordinate(self.coordinate())
            .area(self.area())
            .color(self.color())
            .commodity(self.commodity())
    }
}
#[derive(Clone, Copy)]
pub struct LocationSchemaReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for LocationSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for LocationSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for LocationSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "adjective", self.adjective())?;
        write!(f, ", {}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "belonging", self.belonging())?;
        write!(f, ", {}: {}", "coordinate", self.coordinate())?;
        write!(f, ", {}: {}", "area", self.area())?;
        write!(f, ", {}: {}", "color", self.color())?;
        write!(f, ", {}: {}", "commodity", self.commodity())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> LocationSchemaReader<'r> {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn adjective(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn name(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn belonging(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn coordinate(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn area(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn color(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn commodity(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            SchemaReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            SchemaReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for LocationSchemaReader<'r> {
    type Entity = LocationSchema;
    const NAME: &'static str = "LocationSchemaReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        LocationSchemaReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        SchemaReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        SchemaReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        SchemaReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        SchemaReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        SchemaReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        SchemaReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        SchemaReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct LocationSchemaBuilder {
    pub(crate) adjective: Schema,
    pub(crate) name: Schema,
    pub(crate) belonging: Schema,
    pub(crate) coordinate: Schema,
    pub(crate) area: Schema,
    pub(crate) color: Schema,
    pub(crate) commodity: Schema,
}
impl LocationSchemaBuilder {
    pub const FIELD_COUNT: usize = 7;
    pub fn adjective(mut self, v: Schema) -> Self {
        self.adjective = v;
        self
    }
    pub fn name(mut self, v: Schema) -> Self {
        self.name = v;
        self
    }
    pub fn belonging(mut self, v: Schema) -> Self {
        self.belonging = v;
        self
    }
    pub fn coordinate(mut self, v: Schema) -> Self {
        self.coordinate = v;
        self
    }
    pub fn area(mut self, v: Schema) -> Self {
        self.area = v;
        self
    }
    pub fn color(mut self, v: Schema) -> Self {
        self.color = v;
        self
    }
    pub fn commodity(mut self, v: Schema) -> Self {
        self.commodity = v;
        self
    }
}
impl molecule::prelude::Builder for LocationSchemaBuilder {
    type Entity = LocationSchema;
    const NAME: &'static str = "LocationSchemaBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.adjective.as_slice().len()
            + self.name.as_slice().len()
            + self.belonging.as_slice().len()
            + self.coordinate.as_slice().len()
            + self.area.as_slice().len()
            + self.color.as_slice().len()
            + self.commodity.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.adjective.as_slice().len();
        offsets.push(total_size);
        total_size += self.name.as_slice().len();
        offsets.push(total_size);
        total_size += self.belonging.as_slice().len();
        offsets.push(total_size);
        total_size += self.coordinate.as_slice().len();
        offsets.push(total_size);
        total_size += self.area.as_slice().len();
        offsets.push(total_size);
        total_size += self.color.as_slice().len();
        offsets.push(total_size);
        total_size += self.commodity.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.adjective.as_slice())?;
        writer.write_all(self.name.as_slice())?;
        writer.write_all(self.belonging.as_slice())?;
        writer.write_all(self.coordinate.as_slice())?;
        writer.write_all(self.area.as_slice())?;
        writer.write_all(self.color.as_slice())?;
        writer.write_all(self.commodity.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        LocationSchema::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct DateSchema(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for DateSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for DateSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for DateSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "era", self.era())?;
        write!(f, ", {}: {}", "year", self.year())?;
        write!(f, ", {}: {}", "time", self.time())?;
        write!(f, ", {}: {}", "weather", self.weather())?;
        write!(f, ", {}: {}", "holiday", self.holiday())?;
        write!(f, ", {}: {}", "season", self.season())?;
        write!(f, ", {}: {}", "background", self.background())?;
        write!(f, ", {}: {}", "effect", self.effect())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for DateSchema {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        DateSchema::new_unchecked(v)
    }
}
impl DateSchema {
    const DEFAULT_VALUE: [u8; 340] = [
        84, 1, 0, 0, 36, 0, 0, 0, 74, 0, 0, 0, 112, 0, 0, 0, 150, 0, 0, 0, 188, 0, 0, 0, 226, 0, 0,
        0, 8, 1, 0, 0, 46, 1, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0,
        0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0,
        0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0,
        0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0,
        0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12,
        0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0,
        0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0,
        12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0,
        0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0,
        0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0,
        0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn era(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn year(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn time(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn weather(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn holiday(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn season(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn background(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn effect(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[36..]) as usize;
            Schema::new_unchecked(self.0.slice(start..end))
        } else {
            Schema::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> DateSchemaReader<'r> {
        DateSchemaReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for DateSchema {
    type Builder = DateSchemaBuilder;
    const NAME: &'static str = "DateSchema";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        DateSchema(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DateSchemaReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DateSchemaReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .era(self.era())
            .year(self.year())
            .time(self.time())
            .weather(self.weather())
            .holiday(self.holiday())
            .season(self.season())
            .background(self.background())
            .effect(self.effect())
    }
}
#[derive(Clone, Copy)]
pub struct DateSchemaReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for DateSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for DateSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for DateSchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "era", self.era())?;
        write!(f, ", {}: {}", "year", self.year())?;
        write!(f, ", {}: {}", "time", self.time())?;
        write!(f, ", {}: {}", "weather", self.weather())?;
        write!(f, ", {}: {}", "holiday", self.holiday())?;
        write!(f, ", {}: {}", "season", self.season())?;
        write!(f, ", {}: {}", "background", self.background())?;
        write!(f, ", {}: {}", "effect", self.effect())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> DateSchemaReader<'r> {
    pub const FIELD_COUNT: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn era(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn year(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn time(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn weather(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn holiday(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn season(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn background(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn effect(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[36..]) as usize;
            SchemaReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            SchemaReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for DateSchemaReader<'r> {
    type Entity = DateSchema;
    const NAME: &'static str = "DateSchemaReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        DateSchemaReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        SchemaReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        SchemaReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        SchemaReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        SchemaReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        SchemaReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        SchemaReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        SchemaReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        SchemaReader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct DateSchemaBuilder {
    pub(crate) era: Schema,
    pub(crate) year: Schema,
    pub(crate) time: Schema,
    pub(crate) weather: Schema,
    pub(crate) holiday: Schema,
    pub(crate) season: Schema,
    pub(crate) background: Schema,
    pub(crate) effect: Schema,
}
impl DateSchemaBuilder {
    pub const FIELD_COUNT: usize = 8;
    pub fn era(mut self, v: Schema) -> Self {
        self.era = v;
        self
    }
    pub fn year(mut self, v: Schema) -> Self {
        self.year = v;
        self
    }
    pub fn time(mut self, v: Schema) -> Self {
        self.time = v;
        self
    }
    pub fn weather(mut self, v: Schema) -> Self {
        self.weather = v;
        self
    }
    pub fn holiday(mut self, v: Schema) -> Self {
        self.holiday = v;
        self
    }
    pub fn season(mut self, v: Schema) -> Self {
        self.season = v;
        self
    }
    pub fn background(mut self, v: Schema) -> Self {
        self.background = v;
        self
    }
    pub fn effect(mut self, v: Schema) -> Self {
        self.effect = v;
        self
    }
}
impl molecule::prelude::Builder for DateSchemaBuilder {
    type Entity = DateSchema;
    const NAME: &'static str = "DateSchemaBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.era.as_slice().len()
            + self.year.as_slice().len()
            + self.time.as_slice().len()
            + self.weather.as_slice().len()
            + self.holiday.as_slice().len()
            + self.season.as_slice().len()
            + self.background.as_slice().len()
            + self.effect.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.era.as_slice().len();
        offsets.push(total_size);
        total_size += self.year.as_slice().len();
        offsets.push(total_size);
        total_size += self.time.as_slice().len();
        offsets.push(total_size);
        total_size += self.weather.as_slice().len();
        offsets.push(total_size);
        total_size += self.holiday.as_slice().len();
        offsets.push(total_size);
        total_size += self.season.as_slice().len();
        offsets.push(total_size);
        total_size += self.background.as_slice().len();
        offsets.push(total_size);
        total_size += self.effect.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.era.as_slice())?;
        writer.write_all(self.year.as_slice())?;
        writer.write_all(self.time.as_slice())?;
        writer.write_all(self.weather.as_slice())?;
        writer.write_all(self.holiday.as_slice())?;
        writer.write_all(self.season.as_slice())?;
        writer.write_all(self.background.as_slice())?;
        writer.write_all(self.effect.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        DateSchema::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StorySchema(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StorySchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StorySchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StorySchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "character", self.character())?;
        write!(f, ", {}: {}", "location", self.location())?;
        write!(f, ", {}: {}", "date", self.date())?;
        write!(f, ", {}: {}", "event", self.event())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for StorySchema {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StorySchema::new_unchecked(v)
    }
}
impl StorySchema {
    const DEFAULT_VALUE: [u8; 172] = [
        172, 0, 0, 0, 20, 0, 0, 0, 58, 0, 0, 0, 96, 0, 0, 0, 134, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0,
        0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,
        0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13,
        0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0,
        21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0,
        13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0,
        0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn character(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn location(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn date(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Schema::new_unchecked(self.0.slice(start..end))
    }
    pub fn event(&self) -> Schema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Schema::new_unchecked(self.0.slice(start..end))
        } else {
            Schema::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> StorySchemaReader<'r> {
        StorySchemaReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StorySchema {
    type Builder = StorySchemaBuilder;
    const NAME: &'static str = "StorySchema";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StorySchema(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StorySchemaReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StorySchemaReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .character(self.character())
            .location(self.location())
            .date(self.date())
            .event(self.event())
    }
}
#[derive(Clone, Copy)]
pub struct StorySchemaReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StorySchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StorySchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StorySchemaReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "character", self.character())?;
        write!(f, ", {}: {}", "location", self.location())?;
        write!(f, ", {}: {}", "date", self.date())?;
        write!(f, ", {}: {}", "event", self.event())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> StorySchemaReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn character(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn location(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn date(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        SchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn event(&self) -> SchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            SchemaReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            SchemaReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for StorySchemaReader<'r> {
    type Entity = StorySchema;
    const NAME: &'static str = "StorySchemaReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StorySchemaReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        SchemaReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        SchemaReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        SchemaReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        SchemaReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StorySchemaBuilder {
    pub(crate) character: Schema,
    pub(crate) location: Schema,
    pub(crate) date: Schema,
    pub(crate) event: Schema,
}
impl StorySchemaBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn character(mut self, v: Schema) -> Self {
        self.character = v;
        self
    }
    pub fn location(mut self, v: Schema) -> Self {
        self.location = v;
        self
    }
    pub fn date(mut self, v: Schema) -> Self {
        self.date = v;
        self
    }
    pub fn event(mut self, v: Schema) -> Self {
        self.event = v;
        self
    }
}
impl molecule::prelude::Builder for StorySchemaBuilder {
    type Entity = StorySchema;
    const NAME: &'static str = "StorySchemaBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.character.as_slice().len()
            + self.location.as_slice().len()
            + self.date.as_slice().len()
            + self.event.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.character.as_slice().len();
        offsets.push(total_size);
        total_size += self.location.as_slice().len();
        offsets.push(total_size);
        total_size += self.date.as_slice().len();
        offsets.push(total_size);
        total_size += self.event.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.character.as_slice())?;
        writer.write_all(self.location.as_slice())?;
        writer.write_all(self.date.as_slice())?;
        writer.write_all(self.event.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StorySchema::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct AshWarChronicle(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for AshWarChronicle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for AshWarChronicle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for AshWarChronicle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "character_schema", self.character_schema())?;
        write!(f, ", {}: {}", "location_schema", self.location_schema())?;
        write!(f, ", {}: {}", "date_schema", self.date_schema())?;
        write!(f, ", {}: {}", "story_schema", self.story_schema())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for AshWarChronicle {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        AshWarChronicle::new_unchecked(v)
    }
}
impl AshWarChronicle {
    const DEFAULT_VALUE: [u8; 1212] = [
        188, 4, 0, 0, 20, 0, 0, 0, 146, 1, 0, 0, 188, 2, 0, 0, 16, 4, 0, 0, 126, 1, 0, 0, 40, 0, 0,
        0, 78, 0, 0, 0, 116, 0, 0, 0, 154, 0, 0, 0, 192, 0, 0, 0, 230, 0, 0, 0, 12, 1, 0, 0, 50, 1,
        0, 0, 88, 1, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12,
        0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0,
        0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0,
        12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0,
        0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0,
        0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0,
        0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0,
        0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4,
        0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0,
        13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0,
        0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0,
        0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,
        0, 0, 42, 1, 0, 0, 32, 0, 0, 0, 70, 0, 0, 0, 108, 0, 0, 0, 146, 0, 0, 0, 184, 0, 0, 0, 222,
        0, 0, 0, 4, 1, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12,
        0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0,
        0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0,
        12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0,
        0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0,
        0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0,
        0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0,
        0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4,
        0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0,
        13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 84, 1, 0, 0, 36, 0, 0, 0, 74, 0, 0, 0, 112, 0, 0,
        0, 150, 0, 0, 0, 188, 0, 0, 0, 226, 0, 0, 0, 8, 1, 0, 0, 46, 1, 0, 0, 38, 0, 0, 0, 12, 0,
        0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4,
        0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0,
        13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0,
        0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0,
        0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,
        0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13,
        0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0,
        21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0,
        13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0,
        0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0,
        0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 172, 0, 0, 0, 20, 0, 0, 0, 58, 0, 0, 0, 96, 0, 0, 0, 134,
        0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0,
        13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0,
        0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 38, 0, 0, 0, 12, 0, 0,
        0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,
        0, 0, 38, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 12, 0, 0, 0, 13,
        0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn character_schema(&self) -> CharacterSchema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        CharacterSchema::new_unchecked(self.0.slice(start..end))
    }
    pub fn location_schema(&self) -> LocationSchema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        LocationSchema::new_unchecked(self.0.slice(start..end))
    }
    pub fn date_schema(&self) -> DateSchema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        DateSchema::new_unchecked(self.0.slice(start..end))
    }
    pub fn story_schema(&self) -> StorySchema {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            StorySchema::new_unchecked(self.0.slice(start..end))
        } else {
            StorySchema::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> AshWarChronicleReader<'r> {
        AshWarChronicleReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for AshWarChronicle {
    type Builder = AshWarChronicleBuilder;
    const NAME: &'static str = "AshWarChronicle";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        AshWarChronicle(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AshWarChronicleReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AshWarChronicleReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .character_schema(self.character_schema())
            .location_schema(self.location_schema())
            .date_schema(self.date_schema())
            .story_schema(self.story_schema())
    }
}
#[derive(Clone, Copy)]
pub struct AshWarChronicleReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AshWarChronicleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AshWarChronicleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AshWarChronicleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "character_schema", self.character_schema())?;
        write!(f, ", {}: {}", "location_schema", self.location_schema())?;
        write!(f, ", {}: {}", "date_schema", self.date_schema())?;
        write!(f, ", {}: {}", "story_schema", self.story_schema())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> AshWarChronicleReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn character_schema(&self) -> CharacterSchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        CharacterSchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn location_schema(&self) -> LocationSchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        LocationSchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn date_schema(&self) -> DateSchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        DateSchemaReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn story_schema(&self) -> StorySchemaReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            StorySchemaReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            StorySchemaReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AshWarChronicleReader<'r> {
    type Entity = AshWarChronicle;
    const NAME: &'static str = "AshWarChronicleReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AshWarChronicleReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        CharacterSchemaReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        LocationSchemaReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        DateSchemaReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        StorySchemaReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct AshWarChronicleBuilder {
    pub(crate) character_schema: CharacterSchema,
    pub(crate) location_schema: LocationSchema,
    pub(crate) date_schema: DateSchema,
    pub(crate) story_schema: StorySchema,
}
impl AshWarChronicleBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn character_schema(mut self, v: CharacterSchema) -> Self {
        self.character_schema = v;
        self
    }
    pub fn location_schema(mut self, v: LocationSchema) -> Self {
        self.location_schema = v;
        self
    }
    pub fn date_schema(mut self, v: DateSchema) -> Self {
        self.date_schema = v;
        self
    }
    pub fn story_schema(mut self, v: StorySchema) -> Self {
        self.story_schema = v;
        self
    }
}
impl molecule::prelude::Builder for AshWarChronicleBuilder {
    type Entity = AshWarChronicle;
    const NAME: &'static str = "AshWarChronicleBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.character_schema.as_slice().len()
            + self.location_schema.as_slice().len()
            + self.date_schema.as_slice().len()
            + self.story_schema.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.character_schema.as_slice().len();
        offsets.push(total_size);
        total_size += self.location_schema.as_slice().len();
        offsets.push(total_size);
        total_size += self.date_schema.as_slice().len();
        offsets.push(total_size);
        total_size += self.story_schema.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.character_schema.as_slice())?;
        writer.write_all(self.location_schema.as_slice())?;
        writer.write_all(self.date_schema.as_slice())?;
        writer.write_all(self.story_schema.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        AshWarChronicle::new_unchecked(inner.into())
    }
}
